\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}

%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 
\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

\lstdefinelanguage{C}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}

\colorlet{LightGray}{White!90!Periwinkle}
\colorlet{LightOrange}{Orange!15}
\colorlet{LightGreen}{Green!15}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}

\NewEnviron{NORMAL}{% 
    \scalebox{2}{$\BODY$} 
} 

\declaretheoremstyle[name=Theorem,]{thmsty}
\declaretheorem[style=thmsty,numberwithin=section]{theorem}
\tcolorboxenvironment{theorem}{colback=LightGray}

\declaretheoremstyle[name=Proposition,]{prosty}
\declaretheorem[style=prosty,numberlike=theorem]{proposition}
\tcolorboxenvironment{proposition}{colback=LightOrange}

\declaretheoremstyle[name=Principle,]{prcpsty}
\declaretheorem[style=prcpsty,numberlike=theorem]{principle}
\tcolorboxenvironment{principle}{colback=LightGreen}

\setstretch{1.2}
\geometry{
    textheight=9in,
    textwidth=5.5in,
    top=1in,
    headheight=12pt,
    headsep=25pt,
    footskip=30pt
}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		\LARGE \textbf{\uppercase{Reti di Calcolatori}
		\HRule{2.0pt} \\ [0.6cm] \LARGE{Corso A} \vspace*{10\baselineskip}}
		}

\date{\text{Ultima Compilazione - }\today}
\author{\textbf{Autore} \\ 
		Giuseppe Acocella \\
		2025/26\\
        \url{https://github.com/Peenguino}}

\maketitle
\newpage

\tableofcontents

\newpage

\section{Introduzione alle Reti}

Come facciamo a costruire una rete di computer che sia scalabile e che supporti
\textbf{svariati tipi di applicazioni} come streaming, messaggistica e videochiamate?
Internet ci permette di farlo, e tecnicamente è un insieme di miliardi di host (servers, laptops, smartphones)
connessi tra loro. 

\paragraph{Internet - Vista dei Componenti}

Questa connessione è permessa da specifici componenti:

\begin{enumerate}
    \item \textbf{Link di Comunicazione}: Fibra ottica, rame, onde radio, microonde.
    \item \textbf{Dispositivi di Interconnessione}: I più comuni sono:
    \begin{enumerate}
        \item \textbf{Switch}: Dispositivo che collega tra loro \textbf{più host}.
        \item \textbf{Router}: Dispositivo che collega tra loro \textbf{più reti}.
    \end{enumerate}
    \item \textbf{Reti}: Insieme di host, dispositivi di interconnessione e link gestiti da una stessa organizzazione.
\end{enumerate}

\paragraph{Internet - Vista dei Servizi} Da un punto di vista di servizi offerti invece
Internet:

\begin{enumerate}
    \item E' un \textbf{infrastruttura} che offre servizi alle \textbf{applicazioni distribuite}.
    \item Offre un \textbf{interfaccia di programmazione} (socket) che permette alle applicazioni, distribuite
    su \textbf{host diversi}, di scambiarsi informazioni.
\end{enumerate}

\paragraph{Internet - Vista delle Entità Software}

\begin{enumerate}
    \item \textbf{Applicazioni}: Elaborano e si scambiano informazioni.
    \item \textbf{Protocolli}: Regolano la trasmissione di queste informazioni, definendo
    quindi il formato e l'ordine dei messaggi scambiati tra due o più entità in comunicazione. Due esempi
    noti di protocolli internet sono:
    \begin{enumerate}
        \item \textbf{Trasmission Control Protocol (TCP)}
        \item \textbf{Internet Protocol (IP)}
    \end{enumerate}
\end{enumerate}

\paragraph{Standardizzazione di Protocolli} I protocolli di Internet vengono standardizzatida diversi enti, come:

\begin{enumerate}
    \item Internet Engineering Task Force (IETF). Si basano su una procedura detta RFC (Request for Comments)
    che seguendo passi rigorosi definisce gradualmente nuovi standard per Internet.
    \item IEEE 802 LAN Standards.
    \item World Wide Web Consortium (W3C): Comunità internazionale che sviluppa standard aperti per favorire
    lo sviluppo del Web.
\end{enumerate}

\newpage

\subsection{Tipi di Rete per Dimensione}

Descrizione dei tipi di rete per estensione fisica:

\begin{enumerate}
    \item \textbf{Personal Area Network} (PAN): Connessione personale, ad esempio una Bluetooth.
    \item \textbf{Local Area Network} (LAN): Reti circoscritte ad un area limitata, utilizzano cavi o mezzi wireless per connettersi e sono solitamente proprietarie.
    \item \textbf{Metropolitan Area Network} (MAN): Rete di calcolatori che non supera mai l'estensione fisica indicativa di una "città".
    \item \textbf{Wide Area Network} (WAN): Reti che cercano di interconnettere host separati da distanze geografiche tramite cavi in fibra ottica o ponti radio.
\end{enumerate}

\subsection{Gestione di Internet come Rete di Reti}

Ogni rete locale si espone alle altre reti grazie agli \textbf{Internet Service Provider} (ISP). Come possiamo immaginare però
non connettiamo ogni punto terminale ad ogni altro punto terminale perchè provocherebbe un alta complessità da un punto di vista di collegamenti.
Di conseguenza saranno presenti dei \textbf{Global ISP} che si occupano della gestione del route della comunicazione. Non esiste un solo \textbf{Global ISP} ma \textbf{molteplici}
e questi si connettono tra loro con dei \textbf{Peering Point} su punti d'incontro tra le reti detti \textbf{Internet Exchange Point} (IXP).

\paragraph{Content Provider Network} Idealmente si segue lo schema descritto sopra, ma a volte grandi aziende (Amazon, Google) si posizionano trasversalmente a questa organizzazione descritta, in modo tale da
gestire la propria rete per avvicinare i propri servizi all'utente finale.

\subsection{Reti e Mezzi d'Accesso}

Descriviamo questi elementi caratterizzanti dell'accesso ad una rete:

\begin{enumerate}
    \item \textbf{Rete d'Accesso}: Rete che connette fisicamente un sistema terminale al \textbf{edge router}, ossia il primo router da sorgente a destinazione.
    \item \textbf{Mezzi d'Accesso}: Come passiamo fisicamente dal calcolatore al edge router:
    \begin{enumerate}
        \item \textbf{Cablati (Vincolati)}: Doppino, coassiale, fibra.
        \item \textbf{Wireless (Non Vincolati)}: Onde Radio, microonde, infrarossi.
    \end{enumerate}
\end{enumerate}

\subsubsection{Schema dell'Accesso DSL}

Uno dei primi schemi d'accesso è stato quello Digital Subscriber Line (DSL), dove la compagnia telefonica rappresentava l'ISP.
Risultava quindi necessario splittare la linea telefonica già esistendo, suddividendo il traffico in bande di frequenze diverse:

\begin{enumerate}
    \item \textbf{Canale Telefonico}: $0-4 kHz$
    \item \textbf{Upstream}: $4-50 kHz$
    \item \textbf{Downstream}: $50 kHz \: - \: 1 MHz$
\end{enumerate}

\newpage

In questo modo sarà necessario un multiplexer di accesso alla linea digitale (DSLAM) che permetta di separare i due tipi di comunicazione. Esistono \textbf{versioni diverse}
di \textbf{questo schema}, riferiremo infatti allo schema \textbf{xDSL}, proprio perchè è possibile migliorare le caratteristiche della connessione ad esempio basandosi su una connessione
in \textbf{fibra} tra DSLAM ed ISP, ad esempio:

\begin{enumerate}
    \item \textbf{Fibre To The Cabinet (FTTC)}: Standard VDSL e VDSL2.
    \item \textbf{Fibre To The Derivation Point}.
    \item \textbf{Fibre To The House (FTTH)}: Caratterizzato dai seguenti elementi:
    \begin{enumerate}
        \item Fibra ottica fino all'interno delle abitazioni.
        \item Fibra uscente dalla centrale locale con terminatore ottico di linea \textbf{OLT} viene condivisa da diverse abitazioni.
        \item Il terminatore ottico di rete \textbf{ONT} invece è connesso ad uno splitter tramite fibra dedicata, questo permette la gestione fino al centinaio di abitazioni.
        \item L'\textbf{OLT} si connette al router dell'ISP e tramite questo ad Internet.
    \end{enumerate}
\end{enumerate}

\vspace*{10px}

\subsubsection{Tipi d'Accesso - Cavo, Aziendale, Domestico, Mobile e Satellitare}

Descriviamo queste tipologie di accesso alla rete:

\begin{enumerate}
    \item \textbf{Accesso Via Cavo}: Il segnale ottico viene convertito in segnale elettromagnetico e inviato sulle linee di cavi coassiali per la distribuzione del segnale
    alle varie abitazioni. La velocità potrebbe degradare a causa della distanza o della congestione del canale condiviso tra più abitazioni.
    \item \textbf{Accesso Aziendale}: Nelle aziende i sistemi sono collegati al router di frontiera con una LAN.
    \item \textbf{Accesso Domestico}: Utilizzate tecnologie Ethernet o WiFi per creare LAN domestiche.
    \item \textbf{Accesso Mobile}: Infrastruttura radio mobile definita dagli ISP, può subire degrado di prestazioni a causa di distanza oppure ostacoli.
    \item \textbf{Accesso Satellitare}: Accesso permesso da trasmettitori terrestri che si connettono a satelliti geostazionari (GEO) oppure satelliti a bassa quota (LEO).
    Questo sistema risulta essere il più duttile e non richiede complesse installazioni, ma potrebbe risultare inferiore da alcuni punti di vista come la latenza più alta.
\end{enumerate}

\newpage

\subsection{Nucleo della Rete - Commutazione Circuito vs Pacchetto}

Come determiniamo il percorso effettuato da un messaggio? Come trasferiamo dalla porta di uscita a quella di ingresso di due calcolatori? A queste domande
risponde il tipo di commutazione.

\paragraph{Commutazione di Circuito}

Si instaura un cammino tra gli host in comunicazione e tutte le risorse del canale sono dedicate a loro. Questo causa un utilizzo esclusivo del canale e conseguente spreco
di risorse. Per poter permettere molteplici comunicazioni utilizzando questo tipo di commutazione esistono due politiche:

\begin{enumerate}
    \item \textbf{Frequency Division Multiplexing (FDM)}: Divido il canale in bande di frequenze e le dedico alle diverse comunicazioni.
    \item \textbf{Time Division Multiplexing (TDM)}: Dedico tutto il canale alla coppia di host ma per una finestra di tempo limitata.
\end{enumerate}

\paragraph{Commutazione di Pacchetto}

Il flusso dati di una comunicazione viene suddiviso in \textbf{pacchetti}, e gli viene assegnato un \textbf{header} che mantenga dei metadati riguardanti il flusso dati originale.
Questo tipo di instradamento segue queste fasi:

\begin{enumerate}
    \item \textbf{Suddivisione} in \textbf{pacchetti} ed \textbf{assegnamento header}.
    \item \textbf{Instradamento} del singolo \textbf{pacchetto indipendentemente} dagli altri. Pacchetti di flussi dati diversi possono condividere i canali di comunicazione.
    \item Fase di \textbf{Store and Forward}, ossia prima che il commutatore (router) consegni i pacchetti dovrà prima aspettare che siano del tutto arrivati. Il tipo di Multiplexing
    quindi è statistico e non prefissato. Seguendo questa politica potremmo incorrere anche in problemi di \textbf{perdita di pacchetti} in base al tipo di gestione del buffer di ciascun commutatore.
    Non abbiamo quindi alcuna garanzia sulle prestazioni utilizzando questa tecnica. 
\end{enumerate}

\paragraph{Confronto Caratteristiche Commutazione Circuito/Pacchetto} Elenchiamo pro e contro di ciascuna tecnica:

\begin{enumerate}
    \item \textbf{Commutazione Circuito - Pro}:
    \begin{enumerate}
        \item Prestazioni garantite.
        \item Tecnologie di switching efficienti.
        \item Tariffazioni per ISP semplici da definire.
    \end{enumerate}
    \item \textbf{Commutazione Circuito - Contro}:
    \begin{enumerate}
        \item Segnalazione e configurazione delle tabelle di switching.
        \item Poca ottimizzazione del uso di risorse.
    \end{enumerate}
    \newpage
    \item \textbf{Commutazione Pacchetto - Pro}:
    \begin{enumerate}
        \item Utilizzo ottimale delle risorse.
        \item Non richiede fase di setup e tabelle di switching predefinite.
    \end{enumerate}
    \item \textbf{Commutazione Pacchetto - Contro}:
    \begin{enumerate}
        \item Tecnologie di inoltro non efficienti.
        \item Ritardi variabili.
        \item Rischio di congestione.
    \end{enumerate}

\end{enumerate}

\subsection{Metriche - Prestazioni della Rete (Latenza, Throughput, Prod. Rate/Ritardo)}

Descriviamo due metriche fondamentali delle prestazioni della rete:

\begin{enumerate}
    \item \textbf{Latenza}: Tempo richiesto dal primo bit partito dalla sorgente fino all'arrivo a destinazione. 
    Questa definizione è ideale, infatti dipende anche dal tipo di commutazione, quella di pacchetto con Store $\&$ Bound introduce altre difficoltà.
    Nello specifico le \textbf{cause specifiche} di \textbf{ritardo} nella \textbf{commutazione di pacchetto} sono:

    \begin{enumerate}
        \item \textbf{Ritardo di Elaborazione del Nodo}
        \begin{enumerate}
            \item Controllo errori sui bit.
            \item Determinazione porta di uscita.
        \end{enumerate}
        \item \textbf{Ritardo di Accodamento}
        
        Componente di ritardo più complessa da stabilire, si basa su una \textbf{condizione di stabilità} ossia un rapporto $\rho = \frac{L\:a}{R}$ dove $a$ è velocità
        media di arrivo, $R$ velocità di trasmissione ed $L$ lunghezza media dei pacchetti in bit.
        La condizione $\rho < 1$
        è detta \textbf{condizione di stabilità}.
        \begin{enumerate}
            \item Attesa di trasmissione.
            \item Dipende da intensità e tipo di traffico.
        \end{enumerate}
        \item \textbf{Ritardo di Trasmissione L/R}
        
        Tempo impiegato dal router per trasmettere un pacchetto sul link, con $R\:(bit/sec)$ indichiamo il rate, ossia la velocita di trasmissione del collegamento mentre con 
        $L \: (bit)$ la lunghezza del pacchetto. Il ritardo sarà quindi $d_{trasm} = \frac{L}{R}$. Quindi rappresenta il ritardo di passaggio nel commutatore.
        
        \item \textbf{Ritardo di Propagazione}
        
        Quanto un bit ci mette per spostarsi fisicamente, rappresenta il ritardo di passaggio nel link.
    \end{enumerate}

    Il ritardo complessivo è calcolato come somma di tutti i ritardi calcolati sopra.

\newpage

    \item \textbf{Throughput}
    Rappresenta la capacità effettiva di un link da host $A$ verso host $B$, difficile da definire formalmente, ma diamo questi due riferimenti:

    \begin{enumerate}
        \item \textbf{Throughput Istantaneo}: Velocità in $bit/sec$ a cui host $B$ riceve in ogni istante.
        \item \textbf{Throughput Medio}: Rapporto tra quantità $L$ di dati trasferiti e il tempo $T$ impiegato per il loro trasferimento, ovvero $\frac{L}{T}$.
    \end{enumerate}

    Un potenziale bottleneck influenzerebbe pesantemente questa metrica, in caso quindi di più di un collegamento $q_{i}$ il calcolo sarà $min(q_{1}, ...\:, q_{n})$.
    Il Throughput quindi è differente dalla velocità di trasmissione del collegamento che si pone come upper bound alla metrica del Throughput.

    \item \textbf{Prodotto Rate per Ritardo}
    Il prodotto rate per ritardo rappresenta il "volume" del collegamento, ossia il massimo numero di bit che possono riempire il collegamento ad
    un certo istante.

\end{enumerate}

\subsection{Modello Stratificato}

Lo schema base di gestione delle reti è di tipo \textbf{stratificato}, ossia ciascun livello ha le proprie caratteristiche e responsabilità
seguendo i due criteri di:

\begin{enumerate}
    \item \textbf{Separation of Concern}: Divisione di interessi e responsabilità tra i livelli.
    \item \textbf{Information Hiding}: Si espone solo l'interfaccia di ciascun livello ma non la sua implementazione.
\end{enumerate}

Quindi ogni livello fornisce \textbf{servizi} al livello superiore e scambia informazioni con i livelli adiacenti tramite \textbf{interfacce}.
In questo caso anche in caso di rifattorizzazione di un livello gli altri livelli sarebbero indipendenti dalle modifiche apportate a meno di modifica dell'interfaccia.
Bisogna quindi definire dei protocolli che guidino la gestione di questi livelli.

\paragraph{Cosa è un Protocollo} In protocollo si specificano \textbf{sintassi} di un messaggio, la \textbf{semantica} di un messaggio e \textbf{azioni} da intraprendere in caso di ricezione di messaggio. 

\vspace*{10px}

\subsubsection{Stack Protocollare TCP/IP}

Si compone di $5$ livelli (ciascun livello sarà guidato a sua volta da protocolli):

\vspace*{10px}

\begin{enumerate}
    \item \textbf{Livello Applicazione}: Rappresenta delle applicazioni di rete, oppure collegamenti logici e scambi di messaggi end-to-end tra due processi su host diversi.
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{ftp}, \textbf{smtp}, \textbf{http}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta \textbf{messaggio}.
    \end{enumerate}

    \newpage

    \item \textbf{Livello Trasporto}: Trasferimento dati end-to-end tra processi su host remoti.
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{tcp}, \textbf{udp}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta:
        \begin{enumerate}
            \item \textbf{Segmento} se in \textbf{Protocollo TCP}.
            \item \textbf{Datagramma Utente} se in \textbf{Protocollo UDP}.
        \end{enumerate}
    \end{enumerate}
    \item \textbf{Livello Rete}: Trasferimento e instradamento di \textbf{datagrammi} dalla sorgente alla destinazione. 
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{IP} o \textbf{ICMP}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta \textbf{datagramma}.
    \end{enumerate}
    \item \textbf{Livello Link}: Trasferimento dati in \textbf{frame} attraverso il collegamento tra elementi di rete vicini.
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{PPP} o \textbf{Ethernet}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta \textbf{frame}.
    \end{enumerate} 
    \item \textbf{Livello Fisico}: Trasferimento dei bit di un frame sul mezzo trasmissivo.
\end{enumerate}

\subsubsection{Stack Protocollare ISO/OSI - Cenno Storico}

A differenza dello Stack TCP/IP, che era stato definito dall'IETF, l'ISO/OSI voleva essere uno standard effettivo e formale, definito invece dall'ISO.
Si differenziava dall'TCP/IP perchè aggiungeva due livelli ossia Presentazione e Sessione (compresi nel livello Applicazione nel TCP/IP).
Non dimostrò nessun pratico vantaggio al TCP/IP quindi viene solo usato come riferimento formale.

\subsection{Breve Introduzione alla Sicurezza di Reti}

Un software malevolo può penetrare in un host e può rendere questo host parte di una botnet che distribuisce richieste spam. Esistono varie tecniche:

\begin{enumerate}
    \item \textbf{DDoS} (Distributed Denial of Service):
    \begin{enumerate}
        \item \textbf{Bandwidth Flooding}: Inondazione di pacchetti
        \item \textbf{Connection Flooding}: Inondazione di richieste TCP
    \end{enumerate}
    \item \textbf{Sniffing}: Man in the middle host C collegato ad un mezzo condiviso può ottenere copia di ogni pacchetto trasmesso tra due host A e B.
    \item \textbf{Spoofing}: Man in the middle host C che immette pacchetti spacciandosi per un altro utente tra due host A e B.
\end{enumerate}

\newpage

\paragraph{Parametri e Criteri di Sicurezza} Esistono dei metodi per difendersi da potenziali attacchi:

\begin{enumerate}
    \item \textbf{Autenticazione}: Dimostrazione della propria identità.
    \item \textbf{Crittografia}: Garantisce confidenzialità delle informazioni.
    \item \textbf{Integrità} ed \textbf{Autenticità}: Assicurare che i dati non siano stati alterati e provengano da fonti affidabili.
    \item \textbf{Controllo Accessi}: Limitare l'uso di risorse in base ai ruoli.
    \item \textbf{Utilizzo di Firewall}: Filtrare il traffico tramite dispositivi hardware o software dedicato.
\end{enumerate}

\section{Livello Applicazione}

\subsection{Introduzione a Paradigmi, Protocolli e Tipi d'Utilizzo}

Livello che definisce programmi applicativi che comunicano tra i vari host. Si seguono in genere due paradigmi di comunicazione tra host in questo livello:

\begin{enumerate}
    \item \textbf{Client/Server}: Host server sempre attivo che attende richieste dei vari host client.
    \item \textbf{Peer to Peer}: Tutti i client alla pari, spesso utilizzato nella condivisione di file.
\end{enumerate}

\paragraph{Protocolli} La comunicazione si basa su protocolli aperti (HTTP, SMTP) oppure proprietari. Una web app ad esempio si basa sul protocollo HTTP, invece
un client di posta elettronica può utilizzare il protocollo SMTP. 

\paragraph{Socket e API} Ogni processo, essendo che comunicherà con \textbf{processi di altre macchine}, dovra essere \textbf{identificato}
dall'\textbf{IP della macchina} (da $32$ bit) e dalla \textbf{porta dedicata al processo} (da $16$ bit). Questo avviene grazie all'astrazione dei socket, che
utilizzando IP e porta permettono ai processi di scrivere/leggere da ciascun lato.

\paragraph{Caratterizzazione di un Applicazione} Ciascuna applicazione dovrà scegliere un protocollo da utilizzare in base alla sua caratterizzazione ed in base a specifici criteri:

\begin{enumerate}
    \item \textbf{Throughput}: Tasso effettivo di trasferimento dati, ad esempio un client di mail non avrà bisogno di un alto Throughput.
    \item \textbf{Integrità dei Dati}: Richiesta d'integrita del flusso dei dati, ad esempio una stream potrebbe non richiedere un integrità assoluta.
    \item \textbf{Sensibilità ai Ritardi}: Richiesta di una bassa latenza, ad esempio un videogioco multiplayer potrebbe richiedere una bassa latenza.
\end{enumerate}

L'analisi di questi criteri in relazione all'applicazione permette la scelta del protocollo di trasporto (livello inferiore), quindi nel nostro caso se TCP (orientato allo stream) o UDP (orientato al messaggio).

\newpage

\subsection{TCP vs UDP nel Contesto del Livello Applicazione}

Si sceglie un protocollo del livello trasporto in base alle caratteristiche dell'applicazione in questione. Descriviamone le caratteristiche:

\begin{enumerate}
    \item \textbf{TCP}
    \begin{enumerate}
        \item Orientato allo stream.
        \item Necessario un primo setup tra client e server, questo ha un \textbf{costo} in termini di \textbf{latenza}.
        \item Utilizzo di un buffer limitato d'appoggio per lo stream.
        \item Nessuna garanzia su proprietà di \textbf{Timing} e \textbf{Throughput}.
        \item Attualmente utilizzato in diversi contesti.
    \end{enumerate}
    \item \textbf{UDP}
    \begin{enumerate}
        \item Orientato al messaggio.
        \item Non necessario alcun setup.
        \item Nessuna garanzia su proprietà di \textbf{Timing}, \textbf{Throughput}, \textbf{Trasferimento Dati}, \textbf{Controllo Flusso}, \textbf{Ampiezza Minima di Banda}.
        \item Si accettano potenziali perdite di pacchetti.
    \end{enumerate}
\end{enumerate}

\subsubsection{API e Socket}

\paragraph{API - Application Programming Interface} Un API è un insieme di regole che un programmatore deve rispettare per utilizzare delle risorse. Se un processo
a livello applicazione vuole comunicare un messaggio ad un altro host allo stesso livello allora dovrà interagire con il sistema operativo che implementa i sottostanti
livelli dello stack TCP/IP attraverso un interfaccia.

\paragraph{Interfaccia Socket} API che viene utilizzata da interfaccia tra gli strati di applicazione e trasporto, è l'API di Internet per eccellenza. Dato che un host abbiamo
detto essere individuato grazie ad un IP da $32$ bit, identificheremo un processo e la relativa socket con la porta da $16$ bit.

\vspace*{15px}

Per fare un esempio di API basato su uno dei protocolli del livello trasporto citati prima, mostreremo una bozza di setup tra client e server in TCP e qualche pseudocomando:

\vspace*{15px}

\begin{enumerate}
    \item \textbf{Client}:
    \begin{lstlisting}
    //Apertura Connessione
    connection TCPopen(IPaddress, int)
    \end{lstlisting}
\newpage
    \item \textbf{Server}:
    \begin{lstlisting}
    //Binding
    int tcpbind(int port)
    //Attesa Richieste
    connection TCPaccept(int)
    //Spedire Dati
    void TCPsend(connection, data)
    //Ricevere Dati
    data TCPreceive(connection)
    //Chiusura Connessione:
    void TCPclose(connection)
    \end{lstlisting}
\end{enumerate}

\paragraph{Meccanismi di Sicurezza in TCP/UDP} Nativamente questi livelli non implementano alcun meccanismo di sicurezza, dunque è stato aggiunto un layer con un
socket TLS (Transport Layer Security) che garantisce proprietà come cifratura o integrità dei dati.

\vspace*{30px}

\subsection{Protocollo HTTP - HyperText Transfer Protocol}

Protocollo del livello Applicazione che risulta essere \textbf{generico}, \textbf{stateless} e \textbf{basato sulla tipizzazione} che non deve per forza essere HTML, si negozia infatti il tipo di contenuto.

\vspace*{10px}

Inizialmente nato per le pagine HTML, attualmente utilizzato anche per la comunicazione tra applicazione tramite API REST che permettono esposizione di servizi.

\vspace*{10px}

Dati un client ed un server, il client tramite un \textbf{browser} ottiene una \textbf{pagina HTML} e tante \textbf{risorse dereferenziabili} con \textbf{URL}.

\vspace*{20px}

\paragraph{URI - Uniform Resource Identifier} Permette l'identificazione di una risorsa:

\begin{enumerate}
    \item \textbf{URN - Uniform Resource Name}: Sottoinsieme dell'URI che deve identificare univocamente una risorsa anche quando questa cessa di esistere.
    \item \textbf{URL - Uniform Resource Locator}: Sottoinsieme dell'URI che identifica una risorsa attraverso il suo meccanismo d'accesso.
\end{enumerate}

\newpage

\paragraph{Sintassi di un URL} Un URL segue questo schema per essere definito:

\[ \boxed{<\text{scheme}> // <\text{user}> \::\: <\text{password}> \text{@} <\text{host}> \::\: <\text{port}>/<\text{path}>} \]

\begin{enumerate}
    \item $<\text{user}> \::\: <\text{password}>$ è attualmente deprecata.
    \item $<\text{port}>$ è spesso omessa, dato che se non definita viene utilizzata la porta standard $80$.
    \item $<\text{path}>$ segue lo stesso schema di un file system, dato che storicamente i server web erano statici e l'accesso ad una risorsa avveniva tramite il suo path.
\end{enumerate}

Istanziando al protocollo HTTP come $<\text{scheme}>$ otteniamo:

\[ \boxed{\text{http}\: // <\text{host}> \::\: <\text{port}>/<\text{path}> \:?\: <\text{query}>} \]

\paragraph{Client/Server HTTP} Protocollo basato su richiesta/risposta tra client e server. La \textbf{risposta} è \textbf{stateless}, ossia non dipende dalla richiesta effettuata.
Il protocollo su cui si basa, del livello trasporto, è il TCP, dato che risulta necessario prima \textbf{setuppare} una connessione \textbf{tra server e client}.

\subsubsection{Versioni HTTP, Persistenza e Pipelining}

\paragraph{HTTP/1.0 - Connessione Non Persistente}
Nella versione HTTP 1.0 la connessione non era persistente, e per ciascuna risorsa richiesta veniva aperta una nuova connessione TCP tra client e server. Questo comportava un overhead significativo, poiché ogni richiesta (ad esempio per immagini, fogli di stile, script) necessitava di una nuova connessione, aumentando la latenza e il carico sul server.

\paragraph{HTTP/1.1 - Connessione Persistente e Pipelining}
Con HTTP/1.1 è stata introdotta la \textbf{connessione persistente}: una singola connessione TCP può essere riutilizzata per più richieste e risposte tra client e server, 
riducendo l'overhead di apertura e chiusura delle connessioni. Inoltre, HTTP/1.1 supporta il \textbf{pipelining}, cioè la possibilità di inviare più richieste bufferizzando tramite una pipe di richieste.
Tuttavia, il pipelining non è stato ampiamente adottato a causa di problemi di gestione dell'ordine delle risposte e di compatibilità.

\newpage

\subsubsection{Messaggi HTTP}

In questo protocollo il messaggio può essere o una \textbf{richiesta} o una \textbf{risposta}.
E' facilmente riconoscibile il tipo di messaggio già dalla sua \textbf{startline}, ossia la prima linea del messaggio.

\begin{enumerate}
    \item \textbf{HTTP Request}: Composta da due parti:
    \begin{enumerate}
        \item \textbf{Request Line}:
        \[ \boxed{\text{METODO} \:\: \text{URI} \:\: \text{VERSIONE\_HTTP}} \]
        ad esempio:
        \[ \text{GET} \:\: \text{/dump/page.html} \:\: \text{HTTP/1.1} \]
        \item \textbf{Header}: Insieme di coppie (nomi-valori), che mantengono informazioni 
        
        riguardanti formati preferiti, charset o encodings, ad esempio:

        \[ \text{Accept:} \:\: \text{text/plain; text/html, image/png, application/json} \]
        \[ \text{Accept-Charset} \:\: \text{iso-8859-5, unicode-1-1} \]

    \end{enumerate}

    Durante questa fase è possibile che si instauri una negoziazione tra client e server sulla versione di HTTP da utilizzare. Dato che la comunicazione
    partirà sempre da una richiesta lato client, in base al confronto tra le versioni dell'HTTP in utilizzo di client e server si stabilisce quale usare.
    \item \textbf{HTTP Response}:
    \begin{enumerate}
        \item \textbf{Status Line}:
        \[ \boxed{\text{VERSIONE\_HTTP} \:\: \text{STATUS\_CODE} \:\: \text{FRASE}} \]
        ad esempio:
        \[ \text{HTTP/1.1} \:\: \text{200} \:\: \text{OK} \]
        \vspace*{5px}
        dove lo status code segue questo criterio:
        \vspace*{5px}

        \begin{center}
        \begin{tabular}{ |c|c| } 
        \hline
        1xx & Informational \\ 
        \hline
        2xx & Success \\ 
        \hline
        3xx & Redirection \\ 
        \hline
        4xx & Client Error \\ 
        \hline
        5xx & Server Error \\ 
        \hline
        \end{tabular}
        \end{center}

        \vspace*{5px}
        
        \item \textbf{Response Headers}: Informazioni relative alla risposta che non possono essere
        inserite nella Status Line, come ad esempio la \textbf{location della risorsa} oppure il \textbf{software} utilizzato dal
        \textbf{server} per handlare la richiesta.
        \newpage
        \item \textbf{Entity Headers}: Mantiene informazioni come:
        
        \begin{center}
        \begin{tabular}{ |c|c| } 
        \hline
        Content-Base & URI Assoluta per dereferenziare il body \\ 
        \hline
        Content-Encoding & Codifica del body \\ 
        \hline
        Content-Language & Lingua del body \\ 
        \hline
        Content-Type & Tipo del body \\ 
        \hline
        Expires & Validità Temporale, usato nel Caching \\ 
        \hline
        Last Modified & Ultima modifica della risorsa, usato nel Caching \\ 
        \hline
        \end{tabular}
        \end{center}

    \end{enumerate}
 
\end{enumerate}

\subsubsection{Content Negotiation}

Il client conosce l'URL più generico della risorsa a cui vuole riferirsi. In base ai parametri forniti nell'header della richiesta
sarà il server a dereferenziare l'URL più specifico, magari in base alle informazioni sulla lingua, il tipo di compressione o il formato.

\subsubsection{Metodi dell'HTTP}

Descriviamo le caratteristiche di ciascun metodo messo a disposizione da questo protocollo:

\begin{enumerate}
    \item \textbf{OPTION}: Permette di listare quali siano i metodi chiamabili su una risorsa.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{OPTION} \:\: [RISORSA]}$
    \end{enumerate}
    \item \textbf{GET}: Permette la richiesta di una risorsa, anche in maniera \textbf{parziale} o \textbf{condizionale}.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{GET} \:\: [RISORSA]}$
    \end{enumerate}
    Un comune utilizzo di una GET condizionale è quella basata sull'\textit{If-Modified-Since}, che permette di ottenere la risorsa solo se questa è stata modificata.
    \item \textbf{HEAD}: Permette la richiesta solo della \textit{response line} e dell'\textit{header} di una risorsa, senza il suo \textit{body}.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{HEAD} \:\: [RISORSA]}$
    \end{enumerate}
    \item \textbf{POST}: Permette che il server accetti l'\textit{entità} passata nel \textit{body} della richiesta come \textbf{nuova subordinata} della risorsa identificata dall'\textit{URI}.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{POST} \:\: [RISORSA]}$
    \end{enumerate}
    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.275]{img/metodoPOST.png}
    \end{figure}
    Sarà quindi responsabilità del server trovare un nuovo URI per la nuova risorsa.
    \newpage
    \item \textbf{PUT/DELETE}: Permette di inserire (PUT) o cancellare (DELETE) una risorsa all'URI passato al metodo.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{PUT/DELETE} \:\: [RISORSA]}$
    \end{enumerate}
    In questo caso invece il client dovrà conoscere a priori l'URI della nuova risorsa che sta inserendo.
\end{enumerate}

\paragraph{Metodi Safe ed Idempotenti} Definiamo queste due proprietà e listiamo i metodi che le rispettano:

\begin{enumerate}
    \item \textbf{Metodi Safe}: Non hanno effetti collaterali, dunque non modificano la risorsa, quindi i metodi: GET, HEAD, OPTION e TRACE.
    \item \textbf{Metodi Idempotenti}: Hanno lo stesso effetto se eseguiti una o $n$ volte sulla stessa risorsa, quindi i metodi: GET, HEAD, PUT, DELETE, OPTION, TRACE. 
\end{enumerate}

\subsubsection{Web Caching}

Immaginando di avere una rete locale, assumendo di avere \{$host_1, ... , host_k$\} nella rete, cosa succede se $host_1$ richiede una risorsa
su un host remoto $host_x$ e lo stesso viene fatto da $host_2$ subito dopo? Questo procedimento attualmente non viene per nulla ottimizzato, di conseguenza
sono state formulate politiche di caching che permettono, tramite l'utilizzo di host intermedi, di mantenere le informazioni riguardanti le richieste per non ripeterle.

\paragraph{Server Proxy} Un approccio di \textbf{Web Caching} infatti è quello del \textbf{Server Proxy}, che si pone tra gli host della rete locale ipotizzata ed il server remoto. Se il server proxy cachasse infatti le richieste
allora il secondo host potrebbe acquisire quelle infomazioni senza effettuare richieste al server remoto ma solo richiedendole al server proxy stesso.

% Manca parte cookie, attendi uscita slide

\newpage

%\begin{figure}[htbp]
    %\center
    %\includegraphics[scale=0.4]{img/classiComplessita2.png}
%\end{figure}


\end{document}