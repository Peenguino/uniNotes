\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}

%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 
\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

\lstdefinelanguage{C}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}

\colorlet{LightGray}{White!90!Periwinkle}
\colorlet{LightOrange}{Orange!15}
\colorlet{LightGreen}{Green!15}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}

\NewEnviron{NORMAL}{% 
    \scalebox{2}{$\BODY$} 
} 

\declaretheoremstyle[name=Theorem,]{thmsty}
\declaretheorem[style=thmsty,numberwithin=section]{theorem}
\tcolorboxenvironment{theorem}{colback=LightGray}

\declaretheoremstyle[name=Proposition,]{prosty}
\declaretheorem[style=prosty,numberlike=theorem]{proposition}
\tcolorboxenvironment{proposition}{colback=LightOrange}

\declaretheoremstyle[name=Principle,]{prcpsty}
\declaretheorem[style=prcpsty,numberlike=theorem]{principle}
\tcolorboxenvironment{principle}{colback=LightGreen}

\setstretch{1.2}
\geometry{
    textheight=9in,
    textwidth=5.5in,
    top=1in,
    headheight=12pt,
    headsep=25pt,
    footskip=30pt
}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		\LARGE \textbf{\uppercase{Reti di Calcolatori}
		\HRule{2.0pt} \\ [0.6cm] \LARGE{Corso A} \vspace*{10\baselineskip}}
		}

\date{\text{Ultima Compilazione - }\today}
\author{\textbf{Autore} \\ 
		Giuseppe Acocella \\
		2025/26\\
        \url{https://github.com/Peenguino}}

\maketitle
\newpage

\tableofcontents

\newpage

\section{Introduzione alle Reti}

Come facciamo a costruire una rete di computer che sia scalabile e che supporti
\textbf{svariati tipi di applicazioni} come streaming, messaggistica e videochiamate?
Internet ci permette di farlo, e tecnicamente è un insieme di miliardi di host (servers, laptops, smartphones)
connessi tra loro. 

\paragraph{Internet - Vista dei Componenti}

Questa connessione è permessa da specifici componenti:

\begin{enumerate}
    \item \textbf{Link di Comunicazione}: Fibra ottica, rame, onde radio, microonde.
    \item \textbf{Dispositivi di Interconnessione}: I più comuni sono:
    \begin{enumerate}
        \item \textbf{Switch}: Dispositivo che collega tra loro \textbf{più host}.
        \item \textbf{Router}: Dispositivo che collega tra loro \textbf{più reti}.
    \end{enumerate}
    \item \textbf{Reti}: Insieme di host, dispositivi di interconnessione e link gestiti da una stessa organizzazione.
\end{enumerate}

\paragraph{Internet - Vista dei Servizi} Da un punto di vista di servizi offerti invece
Internet:

\begin{enumerate}
    \item E' un \textbf{infrastruttura} che offre servizi alle \textbf{applicazioni distribuite}.
    \item Offre un \textbf{interfaccia di programmazione} (socket) che permette alle applicazioni, distribuite
    su \textbf{host diversi}, di scambiarsi informazioni.
\end{enumerate}

\paragraph{Internet - Vista delle Entità Software}

\begin{enumerate}
    \item \textbf{Applicazioni}: Elaborano e si scambiano informazioni.
    \item \textbf{Protocolli}: Regolano la trasmissione di queste informazioni, definendo
    quindi il formato e l'ordine dei messaggi scambiati tra due o più entità in comunicazione. Due esempi
    noti di protocolli internet sono:
    \begin{enumerate}
        \item \textbf{Trasmission Control Protocol (TCP)}
        \item \textbf{Internet Protocol (IP)}
    \end{enumerate}
\end{enumerate}

\paragraph{Standardizzazione di Protocolli} I protocolli di Internet vengono standardizzatida diversi enti, come:

\begin{enumerate}
    \item Internet Engineering Task Force (IETF). Si basano su una procedura detta RFC (Request for Comments)
    che seguendo passi rigorosi definisce gradualmente nuovi standard per Internet.
    \item IEEE 802 LAN Standards.
    \item World Wide Web Consortium (W3C): Comunità internazionale che sviluppa standard aperti per favorire
    lo sviluppo del Web.
\end{enumerate}

\newpage

\subsection{Tipi di Rete per Dimensione}

Descrizione dei tipi di rete per estensione fisica:

\begin{enumerate}
    \item \textbf{Personal Area Network} (PAN): Connessione personale, ad esempio una Bluetooth.
    \item \textbf{Local Area Network} (LAN): Reti circoscritte ad un area limitata, utilizzano cavi o mezzi wireless per connettersi e sono solitamente proprietarie.
    \item \textbf{Metropolitan Area Network} (MAN): Rete di calcolatori che non supera mai l'estensione fisica indicativa di una "città".
    \item \textbf{Wide Area Network} (WAN): Reti che cercano di interconnettere host separati da distanze geografiche tramite cavi in fibra ottica o ponti radio.
\end{enumerate}

\subsection{Gestione di Internet come Rete di Reti}

Ogni rete locale si espone alle altre reti grazie agli \textbf{Internet Service Provider} (ISP). Come possiamo immaginare però
non connettiamo ogni punto terminale ad ogni altro punto terminale perchè provocherebbe un alta complessità da un punto di vista di collegamenti.
Di conseguenza saranno presenti dei \textbf{Global ISP} che si occupano della gestione del route della comunicazione. Non esiste un solo \textbf{Global ISP} ma \textbf{molteplici}
e questi si connettono tra loro con dei \textbf{Peering Point} su punti d'incontro tra le reti detti \textbf{Internet Exchange Point} (IXP).

\paragraph{Content Provider Network} Idealmente si segue lo schema descritto sopra, ma a volte grandi aziende (Amazon, Google) si posizionano trasversalmente a questa organizzazione descritta, in modo tale da
gestire la propria rete per avvicinare i propri servizi all'utente finale.

\subsection{Reti e Mezzi d'Accesso}

Descriviamo questi elementi caratterizzanti dell'accesso ad una rete:

\begin{enumerate}
    \item \textbf{Rete d'Accesso}: Rete che connette fisicamente un sistema terminale al \textbf{edge router}, ossia il primo router da sorgente a destinazione.
    \item \textbf{Mezzi d'Accesso}: Come passiamo fisicamente dal calcolatore al edge router:
    \begin{enumerate}
        \item \textbf{Cablati (Vincolati)}: Doppino, coassiale, fibra.
        \item \textbf{Wireless (Non Vincolati)}: Onde Radio, microonde, infrarossi.
    \end{enumerate}
\end{enumerate}

\subsubsection{Schema dell'Accesso DSL}

Uno dei primi schemi d'accesso è stato quello Digital Subscriber Line (DSL), dove la compagnia telefonica rappresentava l'ISP.
Risultava quindi necessario splittare la linea telefonica già esistendo, suddividendo il traffico in bande di frequenze diverse:

\begin{enumerate}
    \item \textbf{Canale Telefonico}: $0-4 kHz$
    \item \textbf{Upstream}: $4-50 kHz$
    \item \textbf{Downstream}: $50 kHz \: - \: 1 MHz$
\end{enumerate}

\newpage

In questo modo sarà necessario un multiplexer di accesso alla linea digitale (DSLAM) che permetta di separare i due tipi di comunicazione. Esistono \textbf{versioni diverse}
di \textbf{questo schema}, riferiremo infatti allo schema \textbf{xDSL}, proprio perchè è possibile migliorare le caratteristiche della connessione ad esempio basandosi su una connessione
in \textbf{fibra} tra DSLAM ed ISP, ad esempio:

\begin{enumerate}
    \item \textbf{Fibre To The Cabinet (FTTC)}: Standard VDSL e VDSL2.
    \item \textbf{Fibre To The Derivation Point}.
    \item \textbf{Fibre To The House (FTTH)}: Caratterizzato dai seguenti elementi:
    \begin{enumerate}
        \item Fibra ottica fino all'interno delle abitazioni.
        \item Fibra uscente dalla centrale locale con terminatore ottico di linea \textbf{OLT} viene condivisa da diverse abitazioni.
        \item Il terminatore ottico di rete \textbf{ONT} invece è connesso ad uno splitter tramite fibra dedicata, questo permette la gestione fino al centinaio di abitazioni.
        \item L'\textbf{OLT} si connette al router dell'ISP e tramite questo ad Internet.
    \end{enumerate}
\end{enumerate}

\vspace*{10px}

\subsubsection{Tipi d'Accesso - Cavo, Aziendale, Domestico, Mobile e Satellitare}

Descriviamo queste tipologie di accesso alla rete:

\begin{enumerate}
    \item \textbf{Accesso Via Cavo}: Il segnale ottico viene convertito in segnale elettromagnetico e inviato sulle linee di cavi coassiali per la distribuzione del segnale
    alle varie abitazioni. La velocità potrebbe degradare a causa della distanza o della congestione del canale condiviso tra più abitazioni.
    \item \textbf{Accesso Aziendale}: Nelle aziende i sistemi sono collegati al router di frontiera con una LAN.
    \item \textbf{Accesso Domestico}: Utilizzate tecnologie Ethernet o WiFi per creare LAN domestiche.
    \item \textbf{Accesso Mobile}: Infrastruttura radio mobile definita dagli ISP, può subire degrado di prestazioni a causa di distanza oppure ostacoli.
    \item \textbf{Accesso Satellitare}: Accesso permesso da trasmettitori terrestri che si connettono a satelliti geostazionari (GEO) oppure satelliti a bassa quota (LEO).
    Questo sistema risulta essere il più duttile e non richiede complesse installazioni, ma potrebbe risultare inferiore da alcuni punti di vista come la latenza più alta.
\end{enumerate}

\newpage

\subsection{Nucleo della Rete - Commutazione Circuito vs Pacchetto}

Come determiniamo il percorso effettuato da un messaggio? Come trasferiamo dalla porta di uscita a quella di ingresso di due calcolatori? A queste domande
risponde il tipo di commutazione.

\paragraph{Commutazione di Circuito}

Si instaura un cammino tra gli host in comunicazione e tutte le risorse del canale sono dedicate a loro. Questo causa un utilizzo esclusivo del canale e conseguente spreco
di risorse. Per poter permettere molteplici comunicazioni utilizzando questo tipo di commutazione esistono due politiche:

\begin{enumerate}
    \item \textbf{Frequency Division Multiplexing (FDM)}: Divido il canale in bande di frequenze e le dedico alle diverse comunicazioni.
    \item \textbf{Time Division Multiplexing (TDM)}: Dedico tutto il canale alla coppia di host ma per una finestra di tempo limitata.
\end{enumerate}

\paragraph{Commutazione di Pacchetto}

Il flusso dati di una comunicazione viene suddiviso in \textbf{pacchetti}, e gli viene assegnato un \textbf{header} che mantenga dei metadati riguardanti il flusso dati originale.
Questo tipo di instradamento segue queste fasi:

\begin{enumerate}
    \item \textbf{Suddivisione} in \textbf{pacchetti} ed \textbf{assegnamento header}.
    \item \textbf{Instradamento} del singolo \textbf{pacchetto indipendentemente} dagli altri. Pacchetti di flussi dati diversi possono condividere i canali di comunicazione.
    \item Fase di \textbf{Store and Forward}, ossia prima che il commutatore (router) consegni i pacchetti dovrà prima aspettare che siano del tutto arrivati. Il tipo di Multiplexing
    quindi è statistico e non prefissato. Seguendo questa politica potremmo incorrere anche in problemi di \textbf{perdita di pacchetti} in base al tipo di gestione del buffer di ciascun commutatore.
    Non abbiamo quindi alcuna garanzia sulle prestazioni utilizzando questa tecnica. 
\end{enumerate}

\paragraph{Confronto Caratteristiche Commutazione Circuito/Pacchetto} Elenchiamo pro e contro di ciascuna tecnica:

\begin{enumerate}
    \item \textbf{Commutazione Circuito - Pro}:
    \begin{enumerate}
        \item Prestazioni garantite.
        \item Tecnologie di switching efficienti.
        \item Tariffazioni per ISP semplici da definire.
    \end{enumerate}
    \item \textbf{Commutazione Circuito - Contro}:
    \begin{enumerate}
        \item Segnalazione e configurazione delle tabelle di switching.
        \item Poca ottimizzazione del uso di risorse.
    \end{enumerate}
    \newpage
    \item \textbf{Commutazione Pacchetto - Pro}:
    \begin{enumerate}
        \item Utilizzo ottimale delle risorse.
        \item Non richiede fase di setup e tabelle di switching predefinite.
    \end{enumerate}
    \item \textbf{Commutazione Pacchetto - Contro}:
    \begin{enumerate}
        \item Tecnologie di inoltro non efficienti.
        \item Ritardi variabili.
        \item Rischio di congestione.
    \end{enumerate}

\end{enumerate}

\subsection{Metriche - Prestazioni della Rete (Latenza, Throughput, Prod. Rate/Ritardo)}

Descriviamo due metriche fondamentali delle prestazioni della rete:

\begin{enumerate}
    \item \textbf{Latenza}: Tempo richiesto dal primo bit partito dalla sorgente fino all'arrivo a destinazione. 
    Questa definizione è ideale, infatti dipende anche dal tipo di commutazione, quella di pacchetto con Store $\&$ Bound introduce altre difficoltà.
    Nello specifico le \textbf{cause specifiche} di \textbf{ritardo} nella \textbf{commutazione di pacchetto} sono:

    \begin{enumerate}
        \item \textbf{Ritardo di Elaborazione del Nodo}
        \begin{enumerate}
            \item Controllo errori sui bit.
            \item Determinazione porta di uscita.
        \end{enumerate}
        \item \textbf{Ritardo di Accodamento}
        
        Componente di ritardo più complessa da stabilire, si basa su una \textbf{condizione di stabilità} ossia un rapporto $\rho = \frac{L\:a}{R}$ dove $a$ è velocità
        media di arrivo, $R$ velocità di trasmissione ed $L$ lunghezza media dei pacchetti in bit.
        La condizione $\rho < 1$
        è detta \textbf{condizione di stabilità}.
        \begin{enumerate}
            \item Attesa di trasmissione.
            \item Dipende da intensità e tipo di traffico.
        \end{enumerate}
        \item \textbf{Ritardo di Trasmissione L/R}
        
        Tempo impiegato dal router per trasmettere un pacchetto sul link, con $R\:(bit/sec)$ indichiamo il rate, ossia la velocita di trasmissione del collegamento mentre con 
        $L \: (bit)$ la lunghezza del pacchetto. Il ritardo sarà quindi $d_{trasm} = \frac{L}{R}$. Quindi rappresenta il ritardo di passaggio nel commutatore.
        
        \item \textbf{Ritardo di Propagazione}
        
        Quanto un bit ci mette per spostarsi fisicamente, rappresenta il ritardo di passaggio nel link.
    \end{enumerate}

    Il ritardo complessivo è calcolato come somma di tutti i ritardi calcolati sopra.

\newpage

    \item \textbf{Throughput}
    Rappresenta la capacità effettiva di un link da host $A$ verso host $B$, difficile da definire formalmente, ma diamo questi due riferimenti:

    \begin{enumerate}
        \item \textbf{Throughput Istantaneo}: Velocità in $bit/sec$ a cui host $B$ riceve in ogni istante.
        \item \textbf{Throughput Medio}: Rapporto tra quantità $L$ di dati trasferiti e il tempo $T$ impiegato per il loro trasferimento, ovvero $\frac{L}{T}$.
    \end{enumerate}

    Un potenziale bottleneck influenzerebbe pesantemente questa metrica, in caso quindi di più di un collegamento $q_{i}$ il calcolo sarà $min(q_{1}, ...\:, q_{n})$.
    Il Throughput quindi è differente dalla velocità di trasmissione del collegamento che si pone come upper bound alla metrica del Throughput.

    \item \textbf{Prodotto Rate per Ritardo}
    Il prodotto rate per ritardo rappresenta il "volume" del collegamento, ossia il massimo numero di bit che possono riempire il collegamento ad
    un certo istante.

\end{enumerate}

\subsection{Modello Stratificato}

Lo schema base di gestione delle reti è di tipo \textbf{stratificato}, ossia ciascun livello ha le proprie caratteristiche e responsabilità
seguendo i due criteri di:

\begin{enumerate}
    \item \textbf{Separation of Concern}: Divisione di interessi e responsabilità tra i livelli.
    \item \textbf{Information Hiding}: Si espone solo l'interfaccia di ciascun livello ma non la sua implementazione.
\end{enumerate}

Quindi ogni livello fornisce \textbf{servizi} al livello superiore e scambia informazioni con i livelli adiacenti tramite \textbf{interfacce}.
In questo caso anche in caso di rifattorizzazione di un livello gli altri livelli sarebbero indipendenti dalle modifiche apportate a meno di modifica dell'interfaccia.
Bisogna quindi definire dei protocolli che guidino la gestione di questi livelli.

\paragraph{Cosa è un Protocollo} In protocollo si specificano \textbf{sintassi} di un messaggio, la \textbf{semantica} di un messaggio e \textbf{azioni} da intraprendere in caso di ricezione di messaggio. 

\vspace*{10px}

\subsubsection{Stack Protocollare TCP/IP}

Si compone di $5$ livelli (ciascun livello sarà guidato a sua volta da protocolli):

\vspace*{10px}

\begin{enumerate}
    \item \textbf{Livello Applicazione}: Rappresenta delle applicazioni di rete, oppure collegamenti logici e scambi di messaggi end-to-end tra due processi su host diversi.
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{ftp}, \textbf{smtp}, \textbf{http}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta \textbf{messaggio}.
    \end{enumerate}

    \newpage

    \item \textbf{Livello Trasporto}: Trasferimento dati end-to-end tra processi su host remoti.
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{tcp}, \textbf{udp}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta:
        \begin{enumerate}
            \item \textbf{Segmento} se in \textbf{Protocollo TCP}.
            \item \textbf{Datagramma Utente} se in \textbf{Protocollo UDP}.
        \end{enumerate}
    \end{enumerate}
    \item \textbf{Livello Rete}: Trasferimento e instradamento di \textbf{datagrammi} dalla sorgente alla destinazione. 
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{IP} o \textbf{ICMP}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta \textbf{datagramma}.
    \end{enumerate}
    \item \textbf{Livello Link}: Trasferimento dati in \textbf{frame} attraverso il collegamento tra elementi di rete vicini.
    \begin{enumerate}
        \item \textbf{Protocolli}: \textbf{PPP} o \textbf{Ethernet}.
        \item \textbf{Entità Informazione del Livello}: L'informazione a questo livello è detta \textbf{frame}.
    \end{enumerate} 
    \item \textbf{Livello Fisico}: Trasferimento dei bit di un frame sul mezzo trasmissivo.
\end{enumerate}

\subsubsection{Stack Protocollare ISO/OSI - Cenno Storico}

A differenza dello Stack TCP/IP, che era stato definito dall'IETF, l'ISO/OSI voleva essere uno standard effettivo e formale, definito invece dall'ISO.
Si differenziava dall'TCP/IP perchè aggiungeva due livelli ossia Presentazione e Sessione (compresi nel livello Applicazione nel TCP/IP).
Non dimostrò nessun pratico vantaggio al TCP/IP quindi viene solo usato come riferimento formale.

\subsection{Breve Introduzione alla Sicurezza di Reti}

Un software malevolo può penetrare in un host e può rendere questo host parte di una botnet che distribuisce richieste spam. Esistono varie tecniche:

\begin{enumerate}
    \item \textbf{DDoS} (Distributed Denial of Service):
    \begin{enumerate}
        \item \textbf{Bandwidth Flooding}: Inondazione di pacchetti
        \item \textbf{Connection Flooding}: Inondazione di richieste TCP
    \end{enumerate}
    \item \textbf{Sniffing}: Man in the middle host C collegato ad un mezzo condiviso può ottenere copia di ogni pacchetto trasmesso tra due host A e B.
    \item \textbf{Spoofing}: Man in the middle host C che immette pacchetti spacciandosi per un altro utente tra due host A e B.
\end{enumerate}

\newpage

\paragraph{Parametri e Criteri di Sicurezza} Esistono dei metodi per difendersi da potenziali attacchi:

\begin{enumerate}
    \item \textbf{Autenticazione}: Dimostrazione della propria identità.
    \item \textbf{Crittografia}: Garantisce confidenzialità delle informazioni.
    \item \textbf{Integrità} ed \textbf{Autenticità}: Assicurare che i dati non siano stati alterati e provengano da fonti affidabili.
    \item \textbf{Controllo Accessi}: Limitare l'uso di risorse in base ai ruoli.
    \item \textbf{Utilizzo di Firewall}: Filtrare il traffico tramite dispositivi hardware o software dedicato.
\end{enumerate}

\section{Livello Applicazione}

\subsection{Introduzione a Paradigmi, Protocolli e Tipi d'Utilizzo}

Livello che definisce programmi applicativi che comunicano tra i vari host. Si seguono in genere due paradigmi di comunicazione tra host in questo livello:

\begin{enumerate}
    \item \textbf{Client/Server}: Host server sempre attivo che attende richieste dei vari host client.
    \item \textbf{Peer to Peer}: Tutti i client alla pari, spesso utilizzato nella condivisione di file.
\end{enumerate}

\paragraph{Protocolli} La comunicazione si basa su protocolli aperti (HTTP, SMTP) oppure proprietari. Una web app ad esempio si basa sul protocollo HTTP, invece
un client di posta elettronica può utilizzare il protocollo SMTP. 

\paragraph{Socket e API} Ogni processo, essendo che comunicherà con \textbf{processi di altre macchine}, dovra essere \textbf{identificato}
dall'\textbf{IP della macchina} (da $32$ bit) e dalla \textbf{porta dedicata al processo} (da $16$ bit). Questo avviene grazie all'astrazione dei socket, che
utilizzando IP e porta permettono ai processi di scrivere/leggere da ciascun lato.

\paragraph{Caratterizzazione di un Applicazione} Ciascuna applicazione dovrà scegliere un protocollo da utilizzare in base alla sua caratterizzazione ed in base a specifici criteri:

\begin{enumerate}
    \item \textbf{Throughput}: Tasso effettivo di trasferimento dati, ad esempio un client di mail non avrà bisogno di un alto Throughput.
    \item \textbf{Integrità dei Dati}: Richiesta d'integrita del flusso dei dati, ad esempio una stream potrebbe non richiedere un integrità assoluta.
    \item \textbf{Sensibilità ai Ritardi}: Richiesta di una bassa latenza, ad esempio un videogioco multiplayer potrebbe richiedere una bassa latenza.
\end{enumerate}

L'analisi di questi criteri in relazione all'applicazione permette la scelta del protocollo di trasporto (livello inferiore), quindi nel nostro caso se TCP (orientato allo stream) o UDP (orientato al messaggio).

\newpage

\subsection{TCP vs UDP nel Contesto del Livello Applicazione}

Si sceglie un protocollo del livello trasporto in base alle caratteristiche dell'applicazione in questione. Descriviamone le caratteristiche:

\begin{enumerate}
    \item \textbf{TCP}
    \begin{enumerate}
        \item Orientato allo stream.
        \item Necessario un primo setup tra client e server, questo ha un \textbf{costo} in termini di \textbf{latenza}.
        \item Utilizzo di un buffer limitato d'appoggio per lo stream.
        \item Nessuna garanzia su proprietà di \textbf{Timing} e \textbf{Throughput}.
        \item Attualmente utilizzato in diversi contesti.
    \end{enumerate}
    \item \textbf{UDP}
    \begin{enumerate}
        \item Orientato al messaggio.
        \item Non necessario alcun setup.
        \item Nessuna garanzia su proprietà di \textbf{Timing}, \textbf{Throughput}, \textbf{Trasferimento Dati}, \textbf{Controllo Flusso}, \textbf{Ampiezza Minima di Banda}.
        \item Si accettano potenziali perdite di pacchetti.
    \end{enumerate}
\end{enumerate}

\subsubsection{API e Socket}

\paragraph{API - Application Programming Interface} Un API è un insieme di regole che un programmatore deve rispettare per utilizzare delle risorse. Se un processo
a livello applicazione vuole comunicare un messaggio ad un altro host allo stesso livello allora dovrà interagire con il sistema operativo che implementa i sottostanti
livelli dello stack TCP/IP attraverso un interfaccia.

\paragraph{Interfaccia Socket} API che viene utilizzata da interfaccia tra gli strati di applicazione e trasporto, è l'API di Internet per eccellenza. Dato che un host abbiamo
detto essere individuato grazie ad un IP da $32$ bit, identificheremo un processo e la relativa socket con la porta da $16$ bit.

\vspace*{15px}

Per fare un esempio di API basato su uno dei protocolli del livello trasporto citati prima, mostreremo una bozza di setup tra client e server in TCP e qualche pseudocomando:

\vspace*{15px}

\begin{enumerate}
    \item \textbf{Client}:
    \begin{lstlisting}
    //Apertura Connessione
    connection TCPopen(IPaddress, int)
    \end{lstlisting}
\newpage
    \item \textbf{Server}:
    \begin{lstlisting}
    //Binding
    int tcpbind(int port)
    //Attesa Richieste
    connection TCPaccept(int)
    //Spedire Dati
    void TCPsend(connection, data)
    //Ricevere Dati
    data TCPreceive(connection)
    //Chiusura Connessione:
    void TCPclose(connection)
    \end{lstlisting}
\end{enumerate}

\paragraph{Meccanismi di Sicurezza in TCP/UDP} Nativamente questi livelli non implementano alcun meccanismo di sicurezza, dunque è stato aggiunto un layer con un
socket TLS (Transport Layer Security) che garantisce proprietà come cifratura o integrità dei dati.

\vspace*{30px}

\subsection{Protocollo HTTP - HyperText Transfer Protocol}

Protocollo del livello Applicazione che risulta essere \textbf{generico}, \textbf{stateless} e \textbf{basato sulla tipizzazione} che non deve per forza essere HTML, si negozia infatti il tipo di contenuto.

\vspace*{10px}

Inizialmente nato per le pagine HTML, attualmente utilizzato anche per la comunicazione tra applicazione tramite API REST che permettono esposizione di servizi.

\vspace*{10px}

Dati un client ed un server, il client tramite un \textbf{browser} ottiene una \textbf{pagina HTML} e tante \textbf{risorse dereferenziabili} con \textbf{URL}.

\vspace*{20px}

\paragraph{URI - Uniform Resource Identifier} Permette l'identificazione di una risorsa:

\begin{enumerate}
    \item \textbf{URN - Uniform Resource Name}: Sottoinsieme dell'URI che deve identificare univocamente una risorsa anche quando questa cessa di esistere.
    \item \textbf{URL - Uniform Resource Locator}: Sottoinsieme dell'URI che identifica una risorsa attraverso il suo meccanismo d'accesso.
\end{enumerate}

\newpage

\paragraph{Sintassi di un URL} Un URL segue questo schema per essere definito:

\[ \boxed{<\text{scheme}> // <\text{user}> \::\: <\text{password}> \text{@} <\text{host}> \::\: <\text{port}>/<\text{path}>} \]

\begin{enumerate}
    \item $<\text{user}> \::\: <\text{password}>$ è attualmente deprecata.
    \item $<\text{port}>$ è spesso omessa, dato che se non definita viene utilizzata la porta standard $80$.
    \item $<\text{path}>$ segue lo stesso schema di un file system, dato che storicamente i server web erano statici e l'accesso ad una risorsa avveniva tramite il suo path.
\end{enumerate}

Istanziando al protocollo HTTP come $<\text{scheme}>$ otteniamo:

\[ \boxed{\text{http}\: // <\text{host}> \::\: <\text{port}>/<\text{path}> \:?\: <\text{query}>} \]

\paragraph{Client/Server HTTP} Protocollo basato su richiesta/risposta tra client e server. La \textbf{risposta} è \textbf{stateless}, ossia non dipende dalla richiesta effettuata.
Il protocollo su cui si basa, del livello trasporto, è il TCP, dato che risulta necessario prima \textbf{setuppare} una connessione \textbf{tra server e client}.

\subsubsection{Versioni HTTP, Persistenza e Pipelining}

\paragraph{HTTP/1.0 - Connessione Non Persistente}
Nella versione HTTP 1.0 la connessione non era persistente, e per ciascuna risorsa richiesta veniva aperta una nuova connessione TCP tra client e server. Questo comportava un overhead significativo, poiché ogni richiesta (ad esempio per immagini, fogli di stile, script) necessitava di una nuova connessione, aumentando la latenza e il carico sul server.

\paragraph{HTTP/1.1 - Connessione Persistente e Pipelining}
Con HTTP/1.1 è stata introdotta la \textbf{connessione persistente}: una singola connessione TCP può essere riutilizzata per più richieste e risposte tra client e server, 
riducendo l'overhead di apertura e chiusura delle connessioni. Inoltre, HTTP/1.1 supporta il \textbf{pipelining}, cioè la possibilità di inviare più richieste bufferizzando tramite una pipe di richieste.
Tuttavia, il pipelining non è stato ampiamente adottato a causa di problemi di gestione dell'ordine delle risposte e di compatibilità.

\newpage

\subsubsection{Messaggi HTTP}

In questo protocollo il messaggio può essere o una \textbf{richiesta} o una \textbf{risposta}.
E' facilmente riconoscibile il tipo di messaggio già dalla sua \textbf{startline}, ossia la prima linea del messaggio.

\begin{enumerate}
    \item \textbf{HTTP Request}: Composta da due parti:
    \begin{enumerate}
        \item \textbf{Request Line}:
        \[ \boxed{\text{METODO} \:\: \text{URI} \:\: \text{VERSIONE\_HTTP}} \]
        ad esempio:
        \[ \text{GET} \:\: \text{/dump/page.html} \:\: \text{HTTP/1.1} \]
        \item \textbf{Header}: Insieme di coppie (nomi-valori), che mantengono informazioni 
        
        riguardanti formati preferiti, charset o encodings, ad esempio:

        \[ \text{Accept:} \:\: \text{text/plain; text/html, image/png, application/json} \]
        \[ \text{Accept-Charset} \:\: \text{iso-8859-5, unicode-1-1} \]

    \end{enumerate}

    Durante questa fase è possibile che si instauri una negoziazione tra client e server sulla versione di HTTP da utilizzare. Dato che la comunicazione
    partirà sempre da una richiesta lato client, in base al confronto tra le versioni dell'HTTP in utilizzo di client e server si stabilisce quale usare.
    \vspace*{5px}

    Un messaggio di HTTP Request deve avere necessariamente una request line.
    \newline
    Un messaggio HTTP Response deve necessariamente avere una status line.

    \item \textbf{HTTP Response}:
    \begin{enumerate}
        \item \textbf{Status Line}:
        \[ \boxed{\text{VERSIONE\_HTTP} \:\: \text{STATUS\_CODE} \:\: \text{FRASE}} \]
        ad esempio:
        \[ \text{HTTP/1.1} \:\: \text{200} \:\: \text{OK} \]
        \vspace*{5px}
        dove lo status code segue questo criterio:
        \vspace*{5px}

        \begin{center}
        \begin{tabular}{ |c|c| } 
        \hline
        1xx & Informational \\ 
        \hline
        2xx & Success \\ 
        \hline
        3xx & Redirection \\ 
        \hline
        4xx & Client Error \\ 
        \hline
        5xx & Server Error \\ 
        \hline
        \end{tabular}
        \end{center}

        \vspace*{5px}
        
        \item \textbf{Response Headers}: Informazioni relative alla risposta che non possono essere
        inserite nella Status Line, come ad esempio la \textbf{location della risorsa} oppure il \textbf{software} utilizzato dal
        \textbf{server} per handlare la richiesta.
        \newpage
        \item \textbf{Entity Headers}: Mantiene informazioni come:
        
        \begin{center}
        \begin{tabular}{ |c|c| } 
        \hline
        Content-Base & URI Assoluta per dereferenziare il body \\ 
        \hline
        Content-Encoding & Codifica del body \\ 
        \hline
        Content-Language & Lingua del body \\ 
        \hline
        Content-Type & Tipo del body \\ 
        \hline
        Expires & Validità Temporale, usato nel Caching \\ 
        \hline
        Last Modified & Ultima modifica della risorsa, usato nel Caching \\ 
        \hline
        \end{tabular}
        \end{center}

    \end{enumerate}


\end{enumerate}

\subsubsection{Content Negotiation}

Il client conosce l'URL più generico della risorsa a cui vuole riferirsi. In base ai parametri forniti nell'header della richiesta
sarà il server a dereferenziare l'URL più specifico, magari in base alle informazioni sulla lingua, il tipo di compressione o il formato.

\subsubsection{Metodi dell'HTTP}

Descriviamo le caratteristiche di ciascun metodo messo a disposizione da questo protocollo:

\begin{enumerate}
    \item \textbf{OPTION}: Permette di listare quali siano i metodi chiamabili su una risorsa.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{OPTION} \:\: [RISORSA]}$
    \end{enumerate}
    \item \textbf{GET}: Permette la richiesta di una risorsa, anche in maniera \textbf{parziale} o \textbf{condizionale}.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{GET} \:\: [RISORSA]}$
    \end{enumerate}
    Un comune utilizzo di una GET condizionale è quella basata sull'\textit{If-Modified-Since}, che permette di ottenere la risorsa solo se questa è stata modificata.
    \item \textbf{HEAD}: Permette la richiesta solo della \textit{response line} e dell'\textit{header} di una risorsa, senza il suo \textit{body}.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{HEAD} \:\: [RISORSA]}$
    \end{enumerate}
    \item \textbf{POST}: Permette che il server accetti l'\textit{entità} passata nel \textit{body} della richiesta come \textbf{nuova subordinata} della risorsa identificata dall'\textit{URI}.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{POST} \:\: [RISORSA]}$
    \end{enumerate}
    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.275]{img/metodoPOST.png}
    \end{figure}
    Sarà quindi responsabilità del server trovare un nuovo URI per la nuova risorsa.
    \newpage
    \item \textbf{PUT/DELETE}: Permette di inserire (PUT) o cancellare (DELETE) una risorsa all'URI passato al metodo.
    \begin{enumerate}
        \item \textbf{Sintassi}: $\boxed{\text{PUT/DELETE} \:\: [RISORSA]}$
    \end{enumerate}
    In questo caso invece il client dovrà conoscere a priori l'URI della nuova risorsa che sta inserendo.
\end{enumerate}

\paragraph{Metodi Safe ed Idempotenti} Definiamo queste due proprietà e listiamo i metodi che le rispettano:

\begin{enumerate}
    \item \textbf{Metodi Safe}: Non hanno effetti collaterali, dunque non modificano la risorsa, quindi i metodi: GET, HEAD, OPTION e TRACE.
    \item \textbf{Metodi Idempotenti}: Hanno lo stesso effetto se eseguiti una o $n$ volte sulla stessa risorsa, quindi i metodi: GET, HEAD, PUT, DELETE, OPTION, TRACE. 
\end{enumerate}

\subsubsection{Web Caching}

Immaginando di avere una rete locale, assumendo di avere \{$host_1, ... , host_k$\} nella rete, cosa succede se $host_1$ richiede una risorsa
su un host remoto $host_x$ e lo stesso viene fatto da $host_2$ subito dopo? Questo procedimento attualmente non viene per nulla ottimizzato, di conseguenza
sono state formulate politiche di caching che permettono, tramite l'utilizzo di host intermedi, di mantenere le informazioni riguardanti le richieste per non ripeterle.

\begin{enumerate}
    \item \textbf{Server Proxy}: Un approccio di \textbf{Web Caching} infatti è quello del \textbf{Server Proxy}, che si pone tra gli host della rete locale ipotizzata ed il server remoto. Se il server proxy cachasse infatti le richieste
    allora il secondo host potrebbe acquisire quelle infomazioni senza effettuare richieste al server remoto ma solo richiedendole al server proxy stesso.
    \item \textbf{User Agent Cache}: Un metodo alternativo è quello che si basa sul mantenimento in locale da parte del browser delle risorse visitate da un utente.
\end{enumerate}

\subsubsection{Cookies}

Il protocollo HTTP è per definizione stateless, di conseguenza risulta necessario un meccanismo che permetta di
mantenere uno stato utente riguardante la sua navigazione su una applicazione web. Vengono quindi utilizzati per autenticazione, ricordare il profilo utente e creare sessioni su un protocollo stateless.

\vspace*{10px}

Si vuole quindi avere la possibilità di numerare e far riconoscere gli utenti sul sito presentando ogni volta un cookie.
Il meccanismo nello specifico si basa su questi passaggi:

\begin{enumerate}
    \item \textbf{Riga di intestazione} nel \textbf{messaggio di risposta} HTTP.
    \item \textbf{Riga di intestazione} nel \textbf{messaggio di richiesta} HTTP.
    \item \textbf{Cookie file} mantenuto dal \textbf{browser} dell'user.
    \item \textbf{Database} di gestione \textbf{cookie} del \textbf{server web}.
\end{enumerate}

\newpage

\paragraph{Cookie First/Third Party} Esistono due tipologie diverse di cookie:

\begin{enumerate}
    \item \textbf{First Party Cookie}: Creati direttamente dal sito web che l'utente sta visitando per mantenere informazioni riguardanti lo stato.
    \item \textbf{Third Party Cookie}: Memorizzano informazioni sensibili riguardanti gli utenti, sono creati e memorizzati da un dominio diverso rispetto a quello del sito web visitato.
\end{enumerate}

\subsection{Protocollo Telnet}

Protocollo di terminale il cui scopo è quello di permettere l'uso interattivo di macchine remote.
Chiaramente i due calcolatori devono poter comunicare a prescindere dai sistemi operativi che utilizzano, di conseguenza si utilizza un \textbf{interfaccia minima} a \textbf{caratteri}.

\paragraph{Protocollo TELNET [RFC 854]} Questo modello standardizzato si basa su un programma client ed uno server, nello specifico si seguono questi passi:

\begin{enumerate}
    \item Il client stabilisce una \textbf{connessione TCP} con il server.
    \item Il \textbf{client} acquisisce l'\textbf{input dei tasti} e lo invia al server, successivamente \textbf{accetta i caratteri} che il \textbf{server manda indietro} e li visualizza sul terminale utente.
    \item Il server accetta la connessione TCP e trasmette i dati al sistema operativo locale.
\end{enumerate}

Il client si connette alla porta $23$ del server e la connessione TCP persiste per la durata della sessione di login.

\paragraph{NVT - Network Virtual Terminal} L'obiettivo di TELNET è quello di poter operare con quanti più calcolatori diversi e di conseguenza sistemi operativi eterogenei. Di conseguenza si definisce un
\textbf{terminale virtuale} che permette la conversione dei comandi dei vari terminali locali e viceversa, creando una vera e propria interfaccia comune di riferimento. Si definiscono quindi dei set di caratteri universali per trasformare quelli delle macchine locali in comunicazione tra loro.

\paragraph{SSH - Secure Shell} Lo standard attuale per comunicazioni tra macchine remote via terminale è SSH, ossia un architettura di protocolli nata per sostituire TELNET ed i suoi problemi di sicurezza. Uno dei servizi principali di SSH è quello di tunneling, infatti grazie al port forwarding
possiamo mettere in comunicazione due processi su due macchine diverse mappando le loro porte a quella di SSH, lasciando quindi viaggiare la comunicazione tra i due processi tramite il tunnel SSH.

\newpage

\subsection{Protocollo SMTP - Simple Mail Transport Protocol}

Uno dei protocolli applicativi più antichi, si basa su due "protagonisti":

\begin{enumerate}
    \item \textbf{User Agent}: Client dell'user che permette l'editing e l'invio di messaggi di posta.
    \item \textbf{Mail Server}: Server dei provider che devono archiviare i messaggi ricevuti, dato che il tipo di comunicazione tra i vari User Agent è asincrona, di conseguenza dovranno immagazzinare in una coda i messaggi in uscita.
\end{enumerate}

\paragraph{Indirizzo Mail - Sintassi} Solitamente un indirizzo è indicato con:

\[ \boxed{\text{local-part} \: @ \: \text{domain-name}} \]

\vspace*{5px}

dove con \textit{local-part} si indica la specifica "cassetta" dell'user nel mail server, mentre
\textit{domain-name} indica l'effettivo mail server.

\paragraph{Spooling dei Mail Server} I Mail Server seguono una tecnica di spooling, ossia tentano di inviare i messaggi di posta settando una connessione TCP con la macchina destinazione. Se la connessione viene aperta e il trasferimento va a buon fine allora
il Mail Server cancella la copia della mail in locale. Altrimenti, se qualcosa dovesse andare storto ritenterebbe la connessione TCP in maniera periodica fino ad un certo intervallo di tempo, se viene superato allora si scarta il messaggio, notificando il mittente della condizione.

\paragraph{Gestione Alias dei Mail Server} Gestione a puntatori di indirizzi di casella postale, ne esistono di due tipi:

\begin{enumerate}
    \item \textbf{Uno a Molti}: Un singolo indirizzo alias riferisce a più indirizzi mail reali.
    \item \textbf{Molti a Uno}: Un singolo indirizzo mail reale ha molti indirizzi alias che lo riferiscono.
\end{enumerate}

\paragraph{Protocollo SMTP [RFC5321]} Si stabilisce una connessione TCP sulla porta $25$, si segue una politica PUSH da parte di ogni client fino a quello precedente al destinatario. Quindi
dal primo user fino all'ultimo Mail Server tutti agiranno da client nei confronti del server destinatario successivo. Tre fasi:

\begin{enumerate}
    \item Handshaking a livello applicativo.
    \item Trasferimento messaggi in coda.
    \item Chiusura.
\end{enumerate}

\vspace*{-10px}

\subparagraph{Comandi SMTP} Questo standard definisce specifici comandi:

\begin{enumerate}
    \item $\text{HELO} \: < \text{client identifier} > $
    \item $\text{MAIL FROM:} \: < \text{reverse-path} > \: < \text{CRLF} > $
    \item $\text{RCPT TO:} \: < \text{forward-path} > \: < \text{CRLF} > $
    \item $\text{DATA}$
    \item $\text{QUIT}$
\end{enumerate}

\newpage

\paragraph{Formato Messaggi SMTP}

I comandi sono formato ASCII, mentre le risposte sono ASCII a 7 bit. Nello specifico, il messaggio è così composto:

\begin{enumerate}
    \item \textbf{Header}: Contiene le linee d'intestazione, come ad esempio \textit{To}, \textit{From}, \textit{Subject}, che \textbf{non} corrispondono ai parametri passati ai comandi SMTP citati prima. 
    \item \textbf{Body}: Contiene il messaggio effettivo, composto da caratteri ASCII a 7 bit.
\end{enumerate}

\paragraph{MIME - Multipurpose Internet Mail Extension} Fino ad ora i body erano composti solo da caratteri ASCII a 7 bit. Si definisce quindi una codifica per trasferimento media e testo non-ASCII.
Si aggiungono quindi dei parametri nelle intestazioni per dichiarare l'utilizzo del MIME nel body.

\subsection{Protocolli POP3/IMAP}

Fino ad ora abbiamo descritto il protocollo SMTP che pusha l'informazione fino all'ultimo mail server. Essendo però un tipo di comunicazione asincrona, sarà il client del destinatario a pullare il messaggio. Si definiscono quindi i protocolli
POP e IMAP.

\begin{enumerate}
    \item \textbf{POP3}: Il client apre una connessione TCP sulla porta 110, si autentica con utente e password e richiede l'elenco dei messaggi e li preleva uno alla volta.
    \item \textbf{IMAP}: Più feature di POP3, permette la gestione logica in folder dei messaggi memorizzati sul server e permette di estrarre solo alcuni componenti dei messaggi.
    \item \textbf{HTTP}: In alternativa, anche HTTP può effettuare richieste ai Mail Server tramite browser.
\end{enumerate}

\subsection{DNS - Domain Name System}

Vogliamo avere la possibilità di dereferenziare nomi e non indirizzi numerici, dato che questi ultimi risultano essere più difficili da ricordare. La domanda quindi è come \textbf{associare indirizzi IP a nomi}.
Inizialmente la gestione di queste associazioni era statica, ma attualmente risulta impossibile utilizzare questa politica, date le dimensioni di Internet.

\paragraph{Architettura Centralizzata vs Distribuita} Potremmo immaginare un unico server con relativo unico database a cui riferirsi per risolvere queste associazioni. Questo però ci vincolerebbe ad una \textbf{pesante dipendenza} da quest'ultimo. Questo dovrebbe gestire miliardi di query al giorno, ed in caso di fallimento del server si bloccherebbe tutto Internet. Si preferisce quindi un architettura distribuita.

\paragraph{Composizione Essenziale del DNS} Si compone di tre elementi fondamentali:

\begin{enumerate}
    \item Uno \textbf{schema di assegnazione} dei \textbf{nomi} gerarchico basato sui domini.
    \item Un \textbf{database distribuito} contenente nomi e corrispondenti IP.
    \item Un \textbf{protocollo} per la \textbf{distribuzione delle informazioni} tra \textbf{name servers}:
    \begin{enumerate}
        \item \textbf{Name Servers}: Comunicano per risolvere nomi.
        \item \textbf{Porta}: Utilizzano porta 53 in UDP (sono a volte TCP).
    \end{enumerate}
\end{enumerate}

\newpage

\paragraph{Servizi Offerti dal DNS} Elenchiamo i servizi offerti dal DNS:

\begin{enumerate}
    \item Risoluzione nomi (hostnames) in indirizzi IP.
    \item \textbf{Host Aliasing}: Più alias possono dereferenziare lo stesso hostname, e di conseguenza, lo stesso indirizzo IP.
    \item \textbf{Distribuzione Carico}: In caso di potenziale carico elevato assegnato ad un server, si fa corrispondere un singolo hostname a più IP per evitare problemi di sovraccarico su una macchina specifica.
    
\end{enumerate}

\paragraph{Struttura Gerarchica di Gestione Domini} Lo spazio dei nomi è definito da una \textbf{struttura gerarchica ad albero} dove ogni nodo è identificato da un \textbf{etichetta}, ossia un \textbf{nome di dominio}.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.5]{img/DNS1.png}
\end{figure}

I domini top-level (.com, .edu, .gov, .net, .org) vengono gestiti dallo IANA.

\subsubsection{Gerarchia dei Name Servers}

Avendo definito il \textbf{DNS} come un \textbf{database distribuito} in una \textbf{gerarchia} di più \textbf{name servers}, allora bisogna definire cosa sia un \textbf{name server}, ossia un 
programma che gestisce la conversione da nome di dominio ad indirizzo IP.

\paragraph{Zone e Domini di Name Servers} Tutte le informazioni per le risoluzioni di nomi sono ripartite su più name server, dunque ciascuno di essi immagazzina le info relative alla propria \textbf{zona} ed i riferimenti ai \textbf{name servers} dei \textbf{domini} di \textbf{livello inferiore}.

\vspace*{10px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.5]{img/DNS2.png}
\end{figure}

\newpage

\paragraph{Ruoli dei Server nella Gerarchia} Elenchiamo tutti i ruoli e le loro responsabilità:

\begin{enumerate}
    \item \textbf{Root Name Server}: Responsabile dei record della zona radice, riconosce tutti i domini TLD (Top Level Domain) e conosce il server TLD che li risolve, quindi restituisce le info sui name server TLD. A questo ruolo corrispondono circa 13 indirizzi IP.
    \item \textbf{Top Level Domain Server}: Mantiene le info dei nomi di dominio che appartengono ad un certo TLD, e restituisce informazioni sui name server di competenza dei sottodomini.
    \item \textbf{Authoritative Name Server}: Responsabile di una certa \textbf{zona}, memorizza nome ed indirizzo IP di un insieme di host di cui può effettuare la traduzione. Questo ruolo può essere suddiviso in altri due sottoruoli:
    \begin{enumerate}
        \item \textbf{Primary Authoritative Name Server}: Mantengono il file di zona.
        \item \textbf{Secondary Authoritative Name Server}: Ricevono il file di zona e offrono il servizio di risoluzione.
    \end{enumerate}
\end{enumerate}

A questa gerarchia si \textbf{aggiunge} un \textbf{ulteriore ruolo}, che \textbf{non appartiene} propriamente alla \textbf{gerarchia}, ma che si occupa da prima interfaccia nel caso in cui un client (es. Browser) tenti di riferire ad un nome:

\begin{enumerate}
    \item \textbf{Local Name Server}: Un server appartenente ad un ISP (Internet Service Provider) che assume il ruolo di proxy, per fare prima un controllo nelle tabelle locali per cercare la risoluzione del nome richiesto dal client, e solo successivamente, in caso di fault, richiede
    la query effettiva al DNS, nello specifico ad un Root Name Server.    
\end{enumerate}

\vspace*{-10px}

\paragraph{Query Ricorsiva/Iterativa} Esistono due tipi diversi di risoluzione dei nomi:

\begin{enumerate}
    \item \textbf{Query Ricorsiva}: Il Local Name Server richiede una conversione completa di nome.
    \item \textbf{Query Iterativa}: Viene restituito al client o al Local Name Server il riferimento al server successivo da contattare per completare la risoluzione di nome.
\end{enumerate}

\vspace*{-20px}

\begin{figure}[htbp]
    \centering
    \begin{minipage}{0.35\textwidth}
        \centering
        \includegraphics[width=\linewidth]{img/queryRicorsiva.png}
        \caption{Query Ricorsiva}
    \end{minipage}
    \hspace{0.8cm}  
    \begin{minipage}{0.37\textwidth}
        \centering
        \includegraphics[width=\linewidth]{img/queryIterativa.png}
        \caption{Query Iterativa}
    \end{minipage}
\end{figure}

\newpage

\paragraph{Caching DNS} Nel DNS si utilizza molto il caching per ridurre richieste che rimbalzano continuamente tra server. Solitamente quindi si mantiene in cache di server DNS il dato in cache in modo non autorevole, e i server invalideranno queste informazioni dopo un periodo fissato. Un altro approccio potrebbe essere quello di mantenere in cache direttamente degli indirizzi 
IP di server DNS TLD (Top Level Domain), evitando di riferirsi più volte ai server radice.

\paragraph{Record DNS} Un DNS è un database distribuito di \textit{resource records} (RR) che seguono la seguente sintassi:

\[ \boxed{\text{RR format}: \:\: ( \text{name, value, type, ttl})} \]

\vspace*{10px}

dove gli elementi vengono così interpretati:

\begin{enumerate}
    \item \textbf{TTL}: Tempo residuo del record in cache.
    \item \textbf{Name} e \textbf{Value}: Dipendono da type.
    \item \textbf{Type}: Esistono vari tipi:
    \vspace*{5px}
    \begin{center}
        \begin{tabular}{|l|l|p{0.45\textwidth}|}
        \hline
        \textbf{Type} & \textbf{Name} & \textbf{Value} \\
        \hline
        A & hostname & indirizzo IP \\
        \hline
        CNAME & hostname (sinonimo) & nome canonico dell'host \\
        \hline
        NS & nome di dominio & hostname dell'Authoritative Name Server per quel dominio \\
        \hline
        MX & nome di dominio & nome canonico del server di posta associato a name \\
        \hline
        \end{tabular}
    \end{center}
\end{enumerate}

\vspace*{15px}

\subsubsection{Protocollo DNS}

L'effettivo protocollo del livello applicazione che si occupa di questa risoluzione di nomi utilizza prevalentemente \textbf{UDP} sulla \textbf{porta 53}.
L'applicazione è detta \textbf{resolver}, effettua polling al server DNS e dopo $n$ richieste o richiede ad un altro server oppure informa l'applicazione con il fallimento.

\vspace*{10px}

\paragraph{Perchè UDP e Quando TCP} Viene utilizzato il protocollo UDP per una questione di riduzione di ritardi, riduzione di overhead causato dal setup di TCP e perchè solitamente le query DNS richiedono pochi dati, quindi rispettano le dimensioni di un pacchetto UDP. A volte viene utilizzato il protocollo TCP, ma questo
accade solo se è necessaria l'affidabilità del trasferimento oppure se si sforano i $512$ byte dei pacchetti UDP.

\newpage

\paragraph{Messaggi del Protocollo DNS} I messaggi di query e reply seguono lo stesso formato:

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.65]{img/messaggioDNS.png}
\end{figure}

Dove ogni campo indica

\begin{enumerate}
    \item \textbf{Identification}: Campo di $16$ bit per l'identificazione di una query, la risposta ad una query usa lo stesso identification id.
    \item \textbf{Flags}: Indicano se query o reply, se desiderata o disponibile la ricorsione e se la risposta è autorevole.
    \item \textbf{Questions}: Nome richiesto e tipo di query.
    \item \textbf{Answers}: RR (\textit{resource records}) in risposta alla query.
    \item \textbf{Authority}: Record per i server di competenza.
    \item \textbf{Additional Info}: Informazioni utili aggiuntive.
\end{enumerate}

\paragraph{DNS e Sicurezza} Dato il funzionamento molto decentralizzato del DNS, esistono vari attacchi che sfruttano questa sua caratteristica:

\begin{enumerate}
    \item \textbf{DNS Cache Poisoning}: Un attaccante invia risposte DNS falsificate ad un DNS Server o ad un client, avvelenandone la cache.
    \item \textbf{Man-in-the-Middle Attack}: Vengono intercettate le comunicazioni tra un client ed un server DNS, ed in questo modo viene indirizzato un obiettivo verso host malevoli.
    \item \textbf{DNS Hijacking}: Si restituiscono risposte non corrette alle query DNS, reindirizzando il client verso siti malevoli alterando le impostazioni DNS. Questo può essere fatto
    a diversi livelli, infatti può essere un Local, Router oppure Rogue Hijacking.
\end{enumerate}

\newpage

\section{Livello Trasporto}

L'obiettivo di questo livello è quello di creare una connessione logica tra processi applicativi su host diversi, assumono quindi di essere collegati a livello fisico, astraendo dalla reale connessione fisica di cui si occuperanno i livelli sottostanti. I protocolli di trasporto vengono
eseguiti nei sistemi terminali, mantenendo la politica per cui si mantengono dumb i dispositivi intermedi e smart quelli terminali.

\subsection{Introduzione al Livello Trasporto}

In questo sottocapitolo definiamo concetti base del livello trasporto.

\paragraph{Servizi del Livello Trasporto} Elenchiamo i servizi offerti da questo livello:

\begin{enumerate}
    \item Offre servizi al livello applicazione, permettendo alle applicazioni di scegliere il modo in cui inviare/ricevere dati secondo uno \textbf{stile} a \textbf{messaggi} oppure a \textbf{stream}.
    \item Comunica con il livello Rete sottostante, che si occupa a sua volta della consegna del datagramma all'host destinatario. 
\end{enumerate}

\paragraph{Servizio Connection/Non Connection Based} Seguendo gli stili definiti sopra possiamo definire anche servizi orientati o meno alla connessione. Nello stile orientato alla connessione
si instaura una logica di server/client dopo una fase di setup, mentre in uno stile non orientato alla connessione i dati vengono visti come messaggi indipendenti.

\paragraph{Azioni del Livello Trasporto} Elenchiamo le azioni di questo livello in base a chi le esegue:

\begin{enumerate}
    \item \textbf{Azioni Mittente}:
    \begin{enumerate}
        \item Riceve un messaggio dal livello applicazione.
        \item Determina i valori dell'header del segmento.
        \item Crea il segmento.
        \item Passa il segmento al livello Rete.
    \end{enumerate}
    \item \textbf{Azioni Destinatario}:
    \begin{enumerate}
        \item Riceve il segmento dal livello Rete.
        \item Controlla i valori dell'header.
        \item Estrae il messaggio del livello applicazione.
        \item Smista il messaggio all'applicazione attraverso la socket.
    \end{enumerate}
\end{enumerate}

\newpage

\subsection{TCP vs UDP e Multiplexing/Demultiplexing}

I due protocolli di trasporto principali hanno caratteristiche differenti:

\begin{enumerate}
    \item \textbf{Protocollo TCP}:
    \begin{enumerate}
        \item Orientato alla Connessione.
        \item Orientato allo Stream.
        \item Gestione della connessione.
        \item Consegna affidabile dei dati.
        \item Controlli di congestione e flow.
    \end{enumerate}
    \item \textbf{Protocollo UDP}:
    \begin{enumerate}
        \item Senza connessione, non affidabile.
        \item Orientato al messaggio.
        \item Estensione del servizio \textit{host to host} del livello rete.
    \end{enumerate}
\end{enumerate}

Entrambi i protocolli però offrono controlli sugli errori e servizi di multiplexing e demultiplexing.

\paragraph{Multi/Demultiplexing} Il livello di trasporto ha la responsabilità di smistare i messaggi ottenuti dal livello di rete tra i vari processi tramite la risoluzione di socket address.
Questo risulta necessario se più processi utilizzano lo stesso protocollo di trasporto per la comunicazione su rete, cosa che accade molto spesso. Quindi abbiamo due attori duali:

\begin{enumerate}
    \item \textbf{Mittente in Multiplexing}: Gestisce i dati da più socket e si occupa dell'aggiunta del header di trasporto.
    \item \textbf{Destinatario in Demultiplexing}: Usa le informazioni nell'header per recapitare i segmenti alla corretta socket.
\end{enumerate}

Nello specifico, nel demultiplexing vengono utilizzati dall'host indirizzi IP e numeri di porta per smistare il segmento verso la corretta socket dato che ogni datagramma si porta dietro un segmento del
livello trasporto ed ogni segmento nell'header mantiene un numero di porta sorgente ed uno di destinazione.

\paragraph{Definizione di Porta} Ogni comunicazione a livello trasporto è univocamente identificata tramite la combinazione $IP/porta$, una \textbf{porta} è quindi definita come un intero a $16$ bit che viene assegnato
ad un processo, più nello specifico è un \textbf{punto di demultiplexing} dei protocolli TCP o UDP. Esistono dei range di porte predefinite, come le \textit{System Ports}, \textit{User Ports} o \textit{Dynamic Ports}. In generale è il
sistema operativo ad occuparsi dell'assegnamento di porte.

\paragraph{Multiplexing TCP/UDP} Esistono differenze tra i tipi di multiplexing dei due protocolli, infatti il protocollo TCP esegue il multiplexing basandosi su una quadrupla con tutte le informazioni su sorgente e destinatario
ossia $(IP_{sorg}, porta_{sorg}, IP_{dest}, porta_{dest})$, mentre il protocollo UDP utilizza la coppia $(IP_{dest}, porta_{dest})$.

\newpage

\subsection{Trasporto UDP}

Servizio di trasporto best effort, i datagrammi UDP possono essere persi o consegnati fuori sequenza. Questo protocollo è orientato al messaggio, quindi ogni datagramma è indipendente e di dimensioni limitate.
Questo garantisce però una semplicità non indifferente, risultando vantaggioso in contesti di applicazioni time-sensitive.

\paragraph{Impieghi e Caratteristiche del Trasporto UDP} E' facile e leggero da gestire, non esiste alcun controllo sulla congestione e le intestazioni non superano gli $8$ byte. Viene impiegato in contesti di applicazioni multimediali, dove sono tollerate le piccole perdite, oppure in altre applicazioni come il DNS, HTTP/3 o SNMP (Simple Network Management Protocol).

\paragraph{Azioni Mittente/Destinatario} Elenchiamo le azioni effettuate in base al tipo di attore:

\begin{enumerate}
    \item \textbf{Azioni Mittente}:
    \begin{enumerate}
        \item Riceve un messaggio del livello Applicazione.
        \item Determina i valori dei campi dell'header UDP.
        \item Crea lo user datagram.
        \item Passa lo user datagram al livello Rete.
    \end{enumerate}
    \item \textbf{Azioni Destinatario}:
    \begin{enumerate}
        \item Riceve lo user datagram dal livello Rete.
        \item Controlla la checksum
        \item Estrae il messaggio di livello Applicazione.
        \item Smista il messaggio attraverso la socket.
    \end{enumerate}
\end{enumerate}

\paragraph{Composizione di un Datagramma UDP} Descriviamo l'entità base del protocollo UDP:

\vspace*{10px}

\begin{center}
    \begin{tabular}{|l|l|}
    \hline
    numero porta sorgente & numero porta destinazione \\
    \hline
    lunghezza & checksum \\
    \hline
    \multicolumn{2}{|c|}{\rule{0pt}{3em}payload\rule{0pt}{3em}} \\
    \hline
    \end{tabular}
\end{center}

\vspace*{10px}

Il messaggio si compone di $8$ byte di intestazione, i numeri di porta per la fase di demultiplexing e la lunghezza del messaggio massima del datagramma UDP è di $65535$ byte.

\newpage

\subsection{Principi di Trasferimento Affidabile}

Definiamo in maniera incrementale un \textbf{protocollo generico} per il trasferimento di dati affidabile, quindi \textbf{senza errori su bit} o \textbf{perdite}.
La complessità del protocollo dipende anche dalle caratteristiche del canale non affidabile su cui si sta appoggiando. In questo caso
il \textbf{livello di rete} è considerato \textbf{non affidabile}, dato che può causare \textbf{perdite}, \textbf{corruzioni} o \textbf{consegne fuori ordine}.

\paragraph{Interfacce per Trasferimento Affidabile} Definiamo le interfacce 

\begin{enumerate}
    \item \textbf{RDT}: Reliable Data Transfer
    \item \textbf{UDT}: Unreliable Data Transfer
\end{enumerate}

che comunicano grazie ai seguenti metodi:

\begin{enumerate}
    \item $rdt\_send()$: Chiamata dall'applicazione per chiedere di consegnare i dati al processo destinatario.
    \item $udt\_send()$: Chiamata da RDT per inviare il pacchetto al destinatario tramite il canale inaffidabile.
    \item $rdt\_receive()$: Chiamata dal protocollo inaffidabile UDT quando il pacchetto arriva sul lato destinatario del canale.
    \item $deliver\_data()$: Chiamata da RDT per consegnare i dati al livello applicazione.
\end{enumerate}

\vspace*{20px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.65]{img/trasferimentoAffidabile1.png}
\end{figure}

\newpage

\subsubsection{RDT 1.0 - Trasferimento su Canale Affidabile}

Questo schema si basa sull'\textbf{assunzione} che il \textbf{canale di rete} sottostante sia \textbf{perfettamente affidabile}.
Quindi tutto il funzionamento si riduce a queste due entità che eseguono le seguenti operazioni:

\begin{enumerate}
    \item Il \textbf{mittente} \textbf{invia} al livello di rete i dati che riceve dal livello applicazione, quindi viene effettuato l'\textbf{incapsulamento del messaggio}, compenendo un \textbf{pacchetto}\footnote{Nel protocollo TCP si parla di segmenti, non di pacchetti, ma nel contesto di trasferimento affidabile generico parleremo di pacchetti.}.
    \item Il \textbf{destinatario inoltra} al \textbf{livello applicazione} i dati che riceve dal livello di rete quindi viene effettuato il \textbf{decapsulamento del pacchetto} estraendo un \textbf{messaggio}.
\end{enumerate}

\subsubsection{RDT 2.0 - Trasferimento su Canale con Errori su Bit}

Indebolendo l'ipotesi dello schema precedente, assumiamo di poter ottenere \textbf{errori sui bit} a causa del \textbf{transito} sul \textbf{canale inaffidabile}.

\paragraph{Ritrasmissione con ACK/NAK} Si utilizzano quindi riscontri positivi \textbf{ACK} per confermare la corretta ricezione e negativi \textbf{NAK} per richiedere ritrasmissione. I protocolli basati su ritrasmissione sono anche detti \textbf{ARQ} (Automatic Repeat ReQuest).

\paragraph{Meccanismi Caratteristici dei ARQ} I protocolli ARQ si basano su questi meccanismi:

\begin{enumerate}
    \item \textbf{Checksum} per \textbf{rilevamento errori sui bit}.
    \item Meccanismo di \textbf{riscontro errore} esplicito con bit settato per \textbf{ACK o NAK}.
    \item \textbf{Ritrasmissione} dei \textbf{pacchetti} ricevuti con errori.
\end{enumerate}

Il tipo di protocollo ARQ che trattiamo è quello \textbf{stop and wait}, ossia il mittente invia un messaggio e poi aspetta riscontro positivo da parte del destinatario prima di inviare il nuovo pacchetto.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.45]{img/RDT2.0_mittente.png}
    \hspace*{30px}
    \includegraphics[scale=0.45]{img/RDT2.0_destinatario.png}
\end{figure}

In questo schema però non si tiene conto di possibili corruzioni di ACK e NAK. Questo problema viene risolto nel
RDT2.1 grazie ad una checksum per il controllo dell'ACK e alla ritrasmissione in caso di corruzione.
Sarà necessario anche quindi un meccanismo di numerazione per capire se il pacchetto sia un duplicato o meno.

\newpage

\subsubsection{RDT 2.1 - Checksum per Controllo Corruzione ACK}

Viene aggiunto un numero di sequenza ai pacchetti lato mittente, che nel caso dello stop and wait di prima sarà quindi $\{ 0,1 \}$. Quindi i passi sono:

\begin{enumerate}
    \item \textbf{Mittente}:
    \begin{enumerate}
        \item Aggiunta numero di sequenza al pacchetto.
        \item Verifica corruzione ACK/NAK tramite checksum.
        \item Quantità stati della macchina raddoppiati: Lo stato tiene conto della numerazione del pacchetto atteso.
    \end{enumerate}
    \item \textbf{Destinatario}:
    \begin{enumerate}
        \item Verifica se pacchetto ricevuto sia duplicato, grazie alla numerazione.
    \end{enumerate}
\end{enumerate}

\vspace*{15px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.4]{img/RDT2.1_mittente.png}
\end{figure}

\vspace*{15px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.45]{img/RDT2.1_destinatario.png}
\end{figure}

\newpage

\subsubsection{RDT 2.2 - Protocollo NAK-free}

Il destinatario non invia NAK espliciti, ma invia gli ACK dell'ultimo pacchetto ricevuto correttamente. Quindi risulta importante includere il numero di sequenza del pacchetto da riscontrare.
Quando il mittente riceve ACK duplicati, ritrasmette il pacchetto corrente.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.4]{img/RDT2.2.png}
\end{figure}

\subsubsection{RDT 3.0 - Timer in Attesa di ACK}

Se la perdita pacchetti esiste nel canale sottostante, allora il mittente potrebbe non ricevere alcuna risposta dal destinatario.
Il mittente dunque aspetta ogni ACK per un massimo di tempo detto \textbf{timeout}. Se il pacchetto non è perso ma solo in ritardo, allora la ristrasimssione invia un duplicato, che sarà individuabile grazie al numero di sequenza da riscontrare.

\subsubsection{Prestazioni e Reale Utilizzo del Canale} RDT3.0 risulta essere molto valido da un punto di vista funzionale, ma da un profilo di prestazioni notiamo che l'utilizzo del canale è molto ridotto a causa dell'attesa del mittente. Volendo quantificare l'utilizzo del canale possiamo definire questo schema con relativa formula:

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.48]{img/RDT3.0.png}
\end{figure}

\vspace*{-15px}

\[ \boxed{U_{send} = \frac{L/R}{RTT + L/R} = \text{tempo utilizzato dal mittente per inviare pacchetti} }\]

Questo tipo di problematiche si risolvono con approcci di \textbf{pipelining}.

\newpage

\subsubsection{Approcci di Pipelining - Go-Back-N (GBN) e Selective Repeat (SR)}

Esistono due approcci di pipelining: Go-Back-N (GBN) e Selective Repeat (SR).

\paragraph{Go-Back-N (GBN)} Definiamo ogni responsabilità dei ruoli di mittente e destinatario.

\begin{enumerate}
    \item \textbf{Mittente}
    \begin{enumerate}
        \item Il mittente può inviare fino ad $n$ pacchetti, ossia la dimensione della sua finestra, senza ricevere ACK.
        \item Si mantengono due puntatori sulla finestra:
        \begin{enumerate}
            \item $base$: primo pacchetto, il più vecchio non riscontrato.
            \item $nextseqnum$: prossimo pacchetto da inviare.
        \end{enumerate}
        \item Possono essere riscontrati pacchetti in maniera cumulativa, scorrendo la finestra di n posizioni su cui si chiama la $ACK(n)$.
        \item Il mittente ritrasmette il pacchetto e tutti quelli con un numero di sequenza maggiore di quello non riscontrato nel caso in cui scade il timer di quello puntato da $base$.
        \begin{figure}[htbp]
            \center
            \includegraphics[scale=0.52]{img/GBN_mittente.png}
        \end{figure}
    \end{enumerate}
    \item \textbf{Destinatario}
    \begin{enumerate}
        \item Invia un ACK ogni volta che riceve un pacchetto.
        \item L'ACK è sempre riferito all'ultimo pacchetto ricevuto in ordine.
        \item Mantiene un solo puntatore $rcv\_base$.
        \item I pacchetti ricevuti fuori ordine vengono scartati.
        \begin{figure}[htbp]
            \center
            \includegraphics[scale=0.6]{img/GBN_destinatario.png}
        \end{figure}
    \end{enumerate}
\end{enumerate}

Questo tipo di approccio ha problemi di prestazioni quando il livello di rete è soggetto a numerose perdite di pacchetti.

\newpage

\paragraph{Selective Repeat (SR)} Questo approccio utilizza ACK individuali per ciascun pacchetto ricevuto correttamente, si appoggia quindi ad un buffer da cui verranno estratti i pacchetti e consegnati in ordine all'applicazione.
Nello specifico, vengono utilizzate \textbf{due finestre} di pacchetti, una \textbf{lato mittente} ed una \textbf{lato destinatario}.

\begin{enumerate}
    \item \textbf{Mittente}
    \begin{enumerate}
        \item Invocazione dall'alto, se c'è un numero di sequenza disponibile allora invia il pacchetto.
        \item In caso di $timeout(n)$, il pacchetto $n$ viene ritrasmesso e risettato il timer.
        \item La gestione di $ACK(n)$ in $[base, base+N+1]$ è definita come:
        \begin{enumerate}
            \item Segna $n$ come ricevuto.
            \item Se $n = base$ allora si fa scorrere la finestra fino al prossimo pacchetto non riscontrato.
        \end{enumerate}
    \end{enumerate} 
    \item \textbf{Destinatario}
    \begin{enumerate}
        \item Se $pktOk \in [rcv\_base, rcv\_base+N+1]$ allora:
        \begin{enumerate}
            \item Invia $ACK(n)$, quindi un nuovo pacchetto è stato correttamente ricevuto.
            \item Se il pacchetto in questione è fuori ordine allora lo si salva nel buffer.
            \item Se il pacchetto è in ordine allora si effettua una consegna di gruppo di pacchetti consecutivi in ordine nel buffer e si lascia scorrere la
            finestra fino al prossimo pacchetto non ricevuto.
        \end{enumerate}
        \item Se $pktOk \in [rcv\_base-N, rcv\_base-1]$ allora:
        \begin{enumerate}
            \item Invia $ACK(n)$, per indicare che il pacchetto già è stato riscontrato.
        \end{enumerate}
        \item Altrimenti scarta il pacchetto.
    \end{enumerate}
\end{enumerate}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.55]{img/selectiveRepeat.png}
\end{figure}

\subsubsection{Riassunto Meccanismi Affidabili}

Listiamo una serie di meccanismi riguardanti il trasferimento affidabile con le relative caratteristiche:

\begin{itemize}
    \item \textbf{ACK}: Indica al mittente che un pacchetto è stato ricevuto correttamente dal destinatario.
    \item \textbf{NAK}: Indica al mittente che un pacchetto è stato \textbf{non} ricevuto correttamente dal destinatario.
    \item \textbf{Ritrasmissione}: Permette al ricevitore di ricevere un pacchetto che è stato corrotto o perso in una trasmissione precedente.
    \item \textbf{Numeri di Sequenza}: Consente il rilevamento di duplicati lato ricevitore.
    \item \textbf{Checksum}: Utilizzato dal ricevitore per rilevare i bit invertiti durante la trasmissione di un pacchetto.
\end{itemize}

\subsection{Protocollo TCP}

Iniziamo la descrizione in verticale sul protocollo TCP.

\paragraph{Proprietà del Protocollo TCP} Il protocollo TCP garantisce queste proprietà:

\begin{itemize}
    \item \textbf{Orientato alla Connessione}: Si effettuano handshake prima dell'inizio della connessione, e lo stato della connessione risiede sui punti terminali della connessione e non su quelli intermedi.
    \item \textbf{Connessione Full Duplex}: La connessione punto a punto è per definizione bidirezionale.
    \item \textbf{Multiplexed}: Consente l'assegnamento di una connessione ad un determinato processo.
    \item \textbf{Controllo della Connessione}: Fornisce meccanismi di inizio e fine trasmissione.
    \item \textbf{Trasferimento di Dati Ordinato e Affidabile}: Permette il controllo di tutti i tipi d'errore quindi dati corrotti, segmenti persi, segmenti duplicati e segmenti fuori sequenza.
    \item \textbf{Controllo di Flusso}: Evita di spedire più dati di quanti non ne possa handlare il destinatario.
    \item \textbf{Controllo di Congestione}: Permette di recuperare da situazioni di sovraccarico della rete.
\end{itemize}

\newpage

\paragraph{Bufferizzazione del Trasferimento} Il flusso di dati in byte fornito dall'applicativo viene suddiviso in segmenti TCP, e per poter permettere questo si utilizzano \textbf{due buffer} uno lato \textbf{mittente} ed uno lato \textbf{destinatario}.
Quindi il flusso di byte viene partizionato in segmenti, ciascuno di essi avrà un header e viene consegnato al livello IP.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.55]{img/bufferizzazioneTCP.png}
\end{figure}

\subsubsection{Formato Segmento TCP}

Dato un flusso di \textbf{byte numerati} TCP suddivide questo stream in segmenti, mantenendo quindi un enumerazione sui segmenti in base a specifici byte, quindi un \textbf{segmento}
è \textbf{identificato dal suo primo byte} di dati \textbf{nel segmento}. In questo modo il riscontro è rappresentato dall'ultimo byte ricevuto correttamente $+1$.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.55]{img/segmentoTCP.png}
\end{figure}

Descriviamo a pagina successiva questa struttura passo passo.

\newpage

\begin{itemize}
    \item \textbf{Porte sorgente e Destinazione}
    \item \textbf{Numero di Sequenza}: Si riferisce al primo byte nel flusso che caratterizza il segmento.
    \item \textbf{Numero di ACK}: Numero di sequenza del prossimo byte atteso, se \texttt{FLAG = 1} allora è un ACK.
    \item \textbf{FLAGS di Bit Codice}: Sei FLAGS che hanno specifiche funzionalità:
    \begin{itemize}
        \item \textbf{URG}: Campo puntatore urgente, da utilizzare se ci sono dati da trasferire in via prioritaria.
        \item \textbf{ACK}: Se settata ad 1 indica che il numero di riscontro contiene dati significativi.
        \item \textbf{PSH}: Se settata ad 1 causa il trasferimento dei dati immediatamente 
        
        all'applicativo.
        \item \textbf{RST}: Richiede il reset della connessione.
        \item \textbf{SYN}: Sincronizza il Numero di Sequenza.
        \item \textbf{FIN}: Se settata ad 1 indica la richiesta di chiusura della connessione.
    \end{itemize}
    \item \textbf{Finestra di Ricezione}: Numero di byte che il destinatario\footnote{Il destinatario in questo caso è chi sta componendo questo segmento, in veste di futuro destinatario, comunica all'altra parte quanto può ricevere nel suo buffer. Questo appiattimento dei ruoli di mittente e destinatario è causato dal fatto che dopo l'handshake i due attori sono posti allo stesso livello.} può ricevere.
    \item \textbf{Checksum}.
    \item \textbf{Opzioni TCP}: Permette la negoziazione di paramentri, come ad esempio la dimensione massima di un segmento (MSS).
\end{itemize}

\vspace*{15px}

\subsubsection{Gestione della Connessione TCP - Handshaking e Chiusura}

Analizziamo le fasi di setup, di effettivo trasferimento di dati e chiusura di una connessione TCP.

\vspace*{8px}

\paragraph{Three Way Handshake} Prima di trasmettere effettivi dati mittente e destinatario si concordano sull'apertura di una connessione, stabilendo anche i parametri della connessione.
I primi segmenti quindi non sono di dati effettivi, permettono anche l'inizializzazione dei due buffer, necessari per il controllo del flusso e della congestione. Al momento di arrivo del terzo segmento la connessione è instaurata.

\vspace*{35px}

Mostriamo a pagina successiva passo passo i dettagli dello scambio di questi $3$ segmenti iniziali.

\newpage

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.45]{img/handshakeTCP.png}
\end{figure}

\begin{itemize}
    \item Il \textbf{client} invia una \textbf{richiesta di connessione} ad un \textbf{server TCP}, settando come attiva la flag \texttt{SYN} e trasmettendo anche un \textbf{numero di sequenza iniziale}.
    \item Il server alloca i buffer e risponde con un segmento di connessione garantita detto \texttt{SYNACK}, nello specifico:
    \begin{itemize}
        \item Con \texttt{SYN} attivo è significativo il valore di sequenza, che è il valore iniziale.
        \item Anche \texttt{ACK} è attivo.
    \end{itemize}
    \item Il client alloca il buffer dal suo fato e invio un riscontro positivo del messaggio del server.
    \begin{itemize}
        \item Si setta \texttt{SYN = 0} per fare in modo che dopo questo terzo segmento inizi l'effettivo scambio di dati.
    \end{itemize}
    Quindi da questo momento in poi server e client sono sullo stesso livello.
\end{itemize}

\paragraph{Chiusura di Connessione TCP} Client e server chiudono ciascuno il loro lato della connessione, inviando segmenti dove \texttt{FIN = 1}. Ciascuno risponderà ad un segmento del genere con un \texttt{ACK}.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.375]{img/chiusuraTCP.png}
\end{figure}

\newpage

Si noti che sulla precedente rappresentazione erano riportati degli stati di una connessione TCP. Ne esistono diversi e in particolare
lo stato \texttt{TIME\_WAIT} è lo stato finale in cui chi sta richiedendo la chiusura resta prima di passare alla reale chiusura. Questo stato è caratterizzato dalla presenza di un timer
che lo fa terminare, e la durata di questo timer è correlata alla MSL, ossia \textbf{Maximum Segment Lifetime}. L'esistenza di questo stato garantisce l'implementazione 
in maniera affidabile della terminazione di una connessione in entrambe le direzioni e l'eliminazione di segmenti duplicati in rete.

\subparagraph{Chiusura Parziale di Connessione TCP} Se uno dei due lati lancia un segmento con \texttt{FIN = 1}, allora non potrà inviare dati ma potrà ancora riceverli mettendosi quindi in stato di \texttt{FIN\_WAIT\_2}.

\subsubsection{Trasferimento Affidabile del TCP}

Un segmento può essere smarrito o corrotto, quindi il TCP crea un servizio di trasferimento affidabile basandosi su questi meccanismi:

\begin{itemize}
    \item \textbf{Checksum}: Permette di scartare segmenti corrotti.
    \item \textbf{Numero di Sequenza}: Enumerazione di segmenti basata sui primi byte di ciascun segmento.
    \item \textbf{Numero di Riscontro}: Numero di sequenza del byte che l'host sta attendendo dall'altro.
    \item \textbf{Riscontro Cumulativo}: Si riscontra fino al primo byte mancante nel flusso.
    \item \textbf{Timer}.
\end{itemize}

\paragraph{Eventi Lato Mittente} Descriviamo il comportamento del mittente:

\begin{itemize}
    \item Riceve i dati dall'applicativo.
    \item Incapsula di dati in segmenti e li numera con la logica a byte definita prima.
    \item Avvia il timer di ritrasmissione RTO solo se non è già assegnato a qualche altro precedente segmento.
    \item Viene effettuata una \textbf{ritrasmissione} se:
    \begin{itemize}
        \item Scade un timeout: Ritrasmette il segmento che non è stato riscontrato, riavviando il timer.
        \item Riceve tre \texttt{ACK} duplicati: Questo è indice di perdita del segmento successivo all'ultimo riscontrato, quindi viene effettuata una \textbf{fast transmission} prima della scadenza del timer.
    \end{itemize}
\end{itemize}

I segmenti ottenuti fuori sequenza possono essere temporaneamente memorizzati dal destinatario, ma la loro gestione dipende dall'implementazione del TCP a cui stiamo facendo riferimento.

\newpage

\paragraph{Eventi Lato Destinatario} Descriviamo il comportamento del destinatario:

\begin{itemize}
    \item Tutti i segmenti inviati contengono ACK.
    \item Se il destinatario \textbf{non ha dati da inviare} e \textbf{riceve un segmento in ordine} allora ritarda l'invio di \texttt{ACK} di $500ms$
    \item Se il destinatario \textbf{riceve il segmento atteso} e il \textbf{precedente non è stato riscontrato} allora invia immediatamente un \texttt{ACK}.
    \item Se il destinatario riceve un \textbf{segmento fuori sequenza}, \textbf{mancante in una sequenza} oppure \textbf{duplicato} allora invia immediatamente un \texttt{ACK}.
\end{itemize}

\subsubsection{TCP RTT, RTO, Stime Timeout e Finestre di Ricezione}

Il tempo di timeout \texttt{RTO} è fondamentale per il funzionamento del TCP e non può essere ne troppo breve ne troppo lungo, va quindi accuratamente stimato. Ci basiamo quindi su due misure:

\begin{itemize}
    \item \texttt{SampleRTT}: Misura del tempo trascorso da quando si invia un segmento a quando si riceve il suo riscontro.
    \item \texttt{EstimatedRTT}: Stima del valore precedente calcolata iterativamente come:
    \[ \boxed{EstimatedRTT_{i+1} = (1-\alpha) EstimatedRTT_{i} + \alpha SampleRTT} \]
    \item \texttt{$RTT_{DEV}$}: Stima della variabilità di RTT determinata con:
    \[ \boxed{RTT_{DEV} = (1-\beta) RTT_{DEV} + \beta | RTT_{SAMPLE} - RTT_{ESTIMATED} |} \]
    \item \texttt{RTO}: Una volta ottenuti questi valori il timeout viene calcolato come:
    \[ \boxed{RTO = RTT_{ESTIMATED} + 4RTT_{DEV}} \]
\end{itemize}

\paragraph{Finestra di Ricezione TCP} I dati inviati dall'applicativo sono mantenuti nel buffer di invio, e la trasmissione si basa su una sliding window che viene fatta scorrere a tempo di ricezione di un \texttt{ACK}.

\vspace*{10px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.4]{img/slidingWindowTCP.png}
\end{figure}

\newpage

\subsubsection{Controllo di Flusso del TCP}

Assumendo che sia mittente sia destinatario abbiano buffer, bisogna valutare cosa succeda nel caso in cui il \textbf{livello di rete} fornisca i dati a \textbf{velocità maggiore}
rispetto a quella dell'\textbf{applicativo a consumarli} dal buffer.

\vspace*{10px}

L'obiettivo del \textbf{controllo di flusso} è quindi quello di mettere in \textbf{relazione} la \textbf{frequenza di invio del mittente} con la \textbf{frequenza di lettura} dell'applicazione \textbf{ricevente}.

Questo meccanismo è implementato tramite una variabile caratteristica \texttt{rwnd} mantenuta dal mittente calcolata come:

\[ \boxed{rwnd = RcvBuffer - (LastByteReceived - LastByteRead)} \]

\vspace*{10px}

Il mittente fornirà questa variabile al destinatario nell'header del segmento e quest'ultimo verficherà se:

\[ \boxed{LastByteSent - LastByteAcked \leq rwnd} \]

Esistono anche dei segmenti sonda di dimensione $1byte$ che il mittente invia per ottenere la dimensione della \texttt{rwnd}.

\subsubsection{Controllo di Congestione del TCP}

Il fenomeno della congestione è causato da più sorgenti che tentano l'invio di dati tramite lo stesso percorso. Questo può provocare lunghi ritardi e perdita di pacchetti.

\paragraph{Approcci per Controllo Congestione} Esistono due tipologie di controllo di congestione di rete:

\begin{enumerate}
    \item \textbf{End To End}: I mezzi intermedi non forniscono alcun feedback, sono quindi gli host terminali tramite sintomi a rilevare la congestione della rete.
    \item \textbf{Assistito dalla Rete}: I router segnalano la congestione\footnote{Questo infrange gli schemi impostati fino ad ora di totale isolamento tra i vari livelli del TCP/IP.}. 
    Definito anche come \textbf{ECN} (Explicit Congestion Notification), dove si utilizzano \texttt{2bit} nell'\textbf{header IP} per indicare \textbf{congestione}. Nello specifico abbiamo un bit \texttt{ECE} settata dalla \textbf{destinazione} nel segmento di riscontro e un bit \texttt{CWR} \textbf{lato mittente} per indicare di aver ricevuto la notifica di congestione.
\end{enumerate}

In TCP quindi il controllo di congestione è implementato imponendo a ciascun mittente di \textbf{limitare la frequenza di invio di pacchetti} sulla connessione in funzione della \textbf{congestione percepita}.

\vspace*{10px}

La dimensione della finestra di invio sarà quindi $min\{ rwnd, cwnd \}$ con \texttt{rwnd} receiver window e \texttt{cwnd} congestion window.
Quindi il rate di invio sarà:

\[ \boxed{rate_{invio} \leq \frac{min\{ rwnd, cwnd \}}{RTT}} \]

\newpage

\paragraph{Algoritmo Controllo Congestione di TCP} Si compone di tre fasi:

\begin{itemize}
    \item Slow Start
    \item AIMD (Additive Increase Multiplicative Decrease)
    \item Reazione agli Eventi Perdita:
    \begin{itemize}
        \item Fast Recovery
        \item Reazione al Timeout
    \end{itemize}
\end{itemize}

Prima della descrizione effettiva delle fasi è utile definire la \texttt{cwnd} (Congestion Window) misurata solitamente in \texttt{MSS} (Maximum Segment Size), ossia la massima quantità di dati trasportabile da un segmento.

\paragraph{AIMD} Fase in cui TCP mittente aumenta proporzionalmente la propria finestra di congestione ad ogni ACK ricevuto:

\begin{itemize}
    \item Ad ogni ACK la finestra di congestione viene incrementata, nello specifico aumento di \texttt{1 MSS} per ogni \texttt{RTT}, quindi $cwnd += \frac{1}{cwnd}$.
\end{itemize}

\paragraph{Slow Start} Fase in cui ad ogni \texttt{ACK} la cwnd viene incrementata di \texttt{1 MSS}, quindi si raddoppia ad ogni \texttt{RTT}. Segue quindi un andamento esponenziale.

\subsubsection{Tipologie di TCP che Istanziano Algoritmo di Controllo Congestione - (Reno, Tahoe, Cubic e Vegas)}

\paragraph{TCP Reno} Istanza delle fasi che abbiamo appena definito, aggiungendo anche gli eventi di perdita:

\begin{itemize}
    \item \textbf{Gestione cwnd}: Viene definita una variabile soglia ad un valore alto.
    \begin{itemize}
        \item Se \texttt{cwnd < soglia} allora si incrementa \texttt{cwnd} aumenta esponenzialmente in \textbf{Slow Start}.
        \item Se \texttt{cwnd > soglia} allora si incrementa \texttt{cwnd} aumenta linearmente in \textbf{Additive Increase}.
    \end{itemize}
    \item \textbf{Eventi di Perdita}: Esistono varie condizioni:
    \begin{itemize}
        \item \textbf{Timeout}: Si setta \texttt{soglia = cwnd} e \texttt{cwnd = 1 MSS} in \textbf{Slow Start}.
        \item \textbf{3 ACK Duplicati}: \texttt{soglia = 1/2cwnd} e \texttt{cwnd = soglia + 3MSS} in \textbf{Fast Recovery}. In particolare in questa fase possono anche accadere altri eventi:
        \begin{itemize}
            \item Se avviene un \textbf{timeout} si va in \textbf{Slow Start}.
            \item Fino a che arrivano \textbf{ACK duplicati} allora \texttt{cwnd = cwnd + 1MSS}.
            \item Se arriva un \textbf{ACK non duplicato} allora \texttt{cwnd = soglia} e si va in \textbf{Congestion Avoidance}.
        \end{itemize}
    \end{itemize}
\end{itemize}

A pagina successiva si mostra un esempio di controllo congestione in TCP Reno.

\newpage

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.4]{img/TCP_Reno.png}
    \caption{Gestione di congestione in TCP Reno}
\end{figure}

Si notano quindi i tre possibili stati ossia Slow Start \texttt{SS}, Congestion Avoidance \texttt{CA} e Fast Recovery \texttt{FR}.

\paragraph{TCP Tahoe} Versione meno recente che comprende solo gli stati di Slow Start e Congestion Avoidance ed è così definito:

\begin{itemize}
    \item \textbf{Timeout} e \textbf{3 ACK Duplicati} sono gestiti allo stesso modo, ossia in \textbf{Slow Start} settando \texttt{soglia = cwnd/2} e \texttt{cwnd = 1MSS}.
\end{itemize}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.4]{img/TCP_Tahoe.png}
    \caption{Gestione di congestione in TCP Tahoe}
\end{figure}

\newpage

\paragraph{TCP Cubic} Cerca di ottimizzare l'andamento "a dente di sega" del TCP Reno settando degli intervalli di ampiezza \texttt{k} e gli incrementi vengono così gestiti:

\begin{itemize}
    \item Incrementi maggiori quando siamo lontani da \texttt{k}.
    \item Incrementi minori quando siamo vicini a \texttt{k}.
\end{itemize}

\vspace*{-15px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.6]{img/TCP_Cubic.png}
\end{figure}

\subsubsection{Throughput, Equità e Cenni di Attacchi TCP}

Avendo mostrato i tre stati di TCP Reno, possiamo dire che macroscopicamente il TCP ha un andamento "a dente di sega". Da questo possiamo analizzarne il throughput, assumendo che il rate di trasmissione
sia circa costante. Quindi:


\begin{itemize}
    \item $W$: Finestra di taglia massima.
    \item $w$: Finestra di taglia minima, ossia $w = \frac{W}{2}$.
    \item \textbf{Throughput}: Se la finestra è $W$ allora è $\frac{W}{RTT}$, invece dopo un evento di perdita quando la finestra è $w$ il throughput diventa $\frac{W}{2RTT}$.
\end{itemize}

Calcolando quindi una media tra le due possibili casistiche otteniamo:

\[ \boxed{throughput = \frac{1}{2} \left( \frac{W}{RTT} + \frac{w}{RTT} \right) = \frac{3}{4} \frac{W}{RTT}} \]

\newpage

%\begin{figure}[htbp]
    %\center
    %\includegraphics[scale=0.4]{img/classiComplessita2.png}
%\end{figure}


\end{document}