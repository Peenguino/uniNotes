\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
\usepackage{fancyvrb} %utilizzato per mathmode in verbatim mode


%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 
\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

\lstdefinelanguage{C}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}

\colorlet{LightGray}{White!90!Periwinkle}
\colorlet{LightOrange}{Orange!15}
\colorlet{LightGreen}{Green!15}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}

\NewEnviron{NORMAL}{% 
    \scalebox{2}{$\BODY$} 
} 

\declaretheoremstyle[name=Theorem,]{thmsty}
\declaretheorem[style=thmsty,numberwithin=section]{theorem}
\tcolorboxenvironment{theorem}{colback=LightGray}

\declaretheoremstyle[name=Proposition,]{prosty}
\declaretheorem[style=prosty,numberlike=theorem]{proposition}
\tcolorboxenvironment{proposition}{colback=LightOrange}

\declaretheoremstyle[name=Principle,]{prcpsty}
\declaretheorem[style=prcpsty,numberlike=theorem]{principle}
\tcolorboxenvironment{principle}{colback=LightGreen}

\setstretch{1.2}
\geometry{
    textheight=9in,
    textwidth=5.5in,
    top=1in,
    headheight=12pt,
    headsep=25pt,
    footskip=30pt
}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		\LARGE \textbf{\uppercase{Base di Dati}
		\HRule{2.0pt} \\ [0.6cm] \LARGE{Corso A} \vspace*{10\baselineskip}}
		}
        
\date{\text{Ultima Compilazione - }\today}
\author{\textbf{Autore} \\ 
		Giuseppe Acocella \\
		2025/26\\
        \url{https://github.com/Peenguino}}

\maketitle
\newpage

\tableofcontents

\newpage

\section{Introduzione}

I database sono insiemi di dati omogenei gestiti in collezioni. Alla base di questo definiamo tabelle, i cui campi possono fare riferimento ad altre tabelle
del database. Il topic di studio del corso è quello dei \textbf{database}, ma in questa introduzione definiamo un confronto con i \textbf{Data Warehouse}, per evidenziarne le \textbf{differenze}, anche
non essendo parte del programma del corso. 

\subsection{OLTP vs OLAP}

Mettiamo a confronto i due tipi di \textbf{ambiti applicativi}:

\begin{enumerate}
    \item \textbf{OLTP - Database (transazionale)}:
    \begin{enumerate}
        \item Utilizzo comune.
        \item Molti users.
        \item Dati analitici e relazionali.
        \item Relazioni statiche.
        \item Una query altera solitamente pochi record della tabella.
        \item Mirato all'utilizzo da parte delle applicazioni.
        \item Aggiornamenti frequenti.
        \item Visione dei dati correnti.
        \item Pensato per le transazioni.
    \end{enumerate}
    \item \textbf{OLAP - Data Warehouse (analitico)}:
    \begin{enumerate}
        \item Pochi utenti esperti.
        \item Dati multidimensionali.
        \item Relazioni dinamiche.
        \item Una query altera molti record della tabella.
        \item Mirato ai soggetti.
        \item Aggiornamenti rari ma massivi.
        \item Visione dei dati storica.
        \item Pensato per l'analisi di trend.
    \end{enumerate}
\end{enumerate}

Per questa motivazione, se dei dati presenti in un database, dovessero servire per un analisi di trend andrebbe effettuata un operazione abbastanza complessa di
estrazione e preparazione per l'immagazzinamento nel Data Warehouse. Entrambi (DB e DW) seguono una politica \textbf{schema first}, ossia viene prima definito uno schema
(insieme di campi) su cui verrà basata la successiva popolazione della collezione di informazioni.

\paragraph{Big Data} Un esempio di collezione di dati che \textbf{non segue} una politica \textbf{schema first}, basandosi infatti sulle proprietà di volume, varietà e velocità
non possono mantenere la rigidità impostata da uno schema. Solitamente sono quindi associati a sistemi NoSQL o approcci Data Lake.

\newpage

\subsection{Data Base Management Systems - DBMS}

Un DBMS (sistema per basi di dati) è un sistema centralizzato o distribuito che offre opportuni linguaggi per:

\begin{enumerate}
    \item Definire lo \textbf{schema} di una DB.
    \item Scegliere le \textbf{strutture dati} a \textbf{supporto} della DB.
    \item \textbf{Memorizzare} dati seguendo i vincoli definiti dai schemi del DB.
    \item Recuperare e modificare dati del DB tramite interrogazioni (\textbf{query}).
\end{enumerate}

Solitamente si pone tra i programmi applicativi e l'effettivo database per permettere l'interazione vincolata tra i due.

\paragraph{Dati gestiti dai DBMS}

Solitamente in un DB sono contenuti:

\begin{enumerate}
    \item \textbf{Metadati}: Descrivono permessi, applicazioni, parametri quantitativi sui dati effettivi. Seguono uno schema definito dal DBMS stesso.
    \item \textbf{Dati}: Rappresentazioni di fatti conformi alle definizioni degli schemi del DB.
    \begin{enumerate}
        \item Sono organizzati in \textbf{insiemi} strutturati ed \textbf{omogenei}, tra i quali sono definite delle \textbf{relazioni}.
        \item Sono accessibili tramite \textbf{transazioni}, operazioni atomiche che non hanno \textbf{mai effetti parziali}.
        \item Sono protetti da accessi non autorizzati e preservati da possibili malfunzionamenti.
        \item Sono utilizzabili in maniera concorrente da più utenti.
    \end{enumerate}
\end{enumerate}

\paragraph{DBMS a Modello Relazionale} Il modello relazionale è il più comune tra i DBMS commerciali e si basa sull'astrazione della \textbf{relazione}, ossia la \textbf{tabella}
vista come un insieme di record con campi ben definiti. Questo ci permette di poter creare tabelle ed interrogarle con un linguaggio ad alto livello.

\paragraph{Funzionalità dei DBMS} Elenchiamo quindi le proprietà garantite da un DBMS:

\begin{enumerate}
    \item Linguaggio per la definizione di un DB.
    \item Linguaggio per l'uso dei dati nel DB.
    \item Meccanismi di controllo del DB.
    \item Strumenti per la gestione admin del DB.
    \item Strumenti per lo sviluppo delle app che richiedono dati dal DB.
\end{enumerate}

\newpage

\subsubsection{Livelli di Vista Dati dei DBMS}

Per garantire le proprietà di \textbf{indipendenza fisica} e \textbf{logica} dei dati è stato proposto l'approccio di tre livelli di descrizione dei dati.

\begin{enumerate}
    \item \textbf{Indipendenza Fisica}: Le applicazioni che utilizzano il DB \textbf{non} devono essere modificati in seguito a modifiche dell'organizzazione fisica
    dei dati nel DB.
    \item \textbf{Indipendenza Logica}: Le applicazioni che utilizzano il DB \textbf{non} devono essere modificati in seguito a modifiche dello schema logico del DB.
\end{enumerate}

Gli effettivi livelli di vista sono invece:

\begin{enumerate}
    \item \textbf{Livello Fisico}: Gestione effettiva dell'immagazzinamento dei dati nel DB, ad esempio in questo livello si scelgono le strutture dati e gli algoritmi
    utilizzati dal DBMS per navigare tra i dati.
    \item \textbf{Livello Logico}: Descrizione della struttura degli insiemi di dati e delle relazioni tra di loro, astraendo completamente dalla loro gestione fisica.
    \item \textbf{Livello Vista Logica}: Sottoinsieme del livello logico esposto alle applicazioni esterne.
\end{enumerate}

\subsubsection{Meccanismi di Controllo Dati e Transazioni dei DBMS}

I DBMS cercano di garantire queste proprietà sui dati immagazzinati in un DB:

\begin{enumerate}
    \item \textbf{Integrità}: Mantenimento delle proprietà definite dallo schema.
    \item \textbf{Sicurezza}: Protezione dei dati da usi non autorizzati.
    \item \textbf{Affidabilità}: Protezione in caso di malfunzionamenti hardware/software.
\end{enumerate}

\paragraph{Transazioni - Operazioni Atomiche} Una transazione è una sequenza di azioni di lettura e scrittura in memoria permanente e di elaborazioni di dati in memoria
temporanea secondo queste proprietà:

\begin{enumerate}
    \item \textbf{Atomicità}: Le transazioni terminate prematuramente sono trattate come se non fossero mai iniziate. I loro effetti sul DB sono nulli.
    \item \textbf{Persistenza}: Le transazioni terminate con successo sono permanenti, ossia non alterabili neanche da malfunzionamenti.
    \item \textbf{Serializzabilità}: L'esecuzione concorrente di più transazioni è vista come un esecuzione seriale di transazioni.
\end{enumerate}

\paragraph{Riepilogo Pro e Contro Utilizzo DBMS}

Elenchiamo rapidamente i pro e i contro di questo approccio:

\begin{enumerate}
    \item \textbf{Pro}: Indipendenza dei dati, recupero efficiente dei dati, integrità e sicurezza, accessi interattivi e concorrenti, amministrazione e riduzione dei tempi di
    sviluppo delle applicazioni.
    \item \textbf{Contro}: Necessaria la definizione di uno schema, gestiscono solo dati strutturati ed omogenei, ottimizzati per app OLTP e non per OLAP.
\end{enumerate}

\newpage

\section{Progettazione di una Base Dati}

La nascita dei database è causata da alcune problematiche presenti in sistemi di
gestione informazioni più datati. Un classico esempio di problematica è quella della
\textbf{ridondanza logica}, ossia un informazione ripetuta più volte tra vari record. In queste
casistiche si preferisce astrarre e fare riferimento solo una volta ad un dato.

\subsection{Attori e Fasi della Progettazione di DB}

Elenchiamo attori e fasi della progettazione di una base dati.

\paragraph{Attori della Progettazione} Elenchiamoli:

\begin{enumerate}
    \item \textbf{Committente}: Azienda che commissiona la creazione di una base dati, per una propria necessità.
    \item \textbf{Consulente}: Progettisti del DB.
    \item \textbf{Utente}: Chi usufruirà del DB, solitamente un dipendente del committente.
    \item \textbf{DB Administrator}: Amministratore del DB.
\end{enumerate}

\paragraph{Fasi della Progettazione} Si definiscono fasi specifiche della progettazione di un DB:

\begin{enumerate}
    \item \textbf{Specifica Requisiti Committente}: Il committente deve definire le proprie necessità ed il consulente deve
    raccogliere le informazioni.
    \item \textbf{Progettazione Concettuale}: Realizzazione di uno schema concettuale orientato agli oggetti che deve essere osservabile ed
    approvato dal committente. In questa fase si astrae completamente da dettagli tecnici d'implementazione/ottimizzazione
    proprio perchè deve risultare semplice al committente e non deve causare ridondanza logica.
    \item \textbf{Progettazione Logica}: Concretizzazione della progettazione concettuale tramite linguaggi relazionali.
    \item \textbf{Progettazione Fisica}: Allocazione fisica delle tabelle generate dal linguaggio relazionale della progettazione logica.
\end{enumerate}

\paragraph{Progettazione come Modellazione} Spesso il committente stesso non riesce a rendere esplicite tutte le sue necessità, di conseguenza
è compito del consulente capire a fondo i comportamenti ed i dettagli necessari alla modellazione logica.

\subsection{Progettazione Concettuale}

Questo linguaggio si basa su $3$ operatori diversi:

\begin{enumerate}
    \item \textbf{Classi (aka Collezioni)}: Ad esempio la classe Persone di entità persona. Formalmente una classe modella un insieme di entità omogenee. Queste possono essere
    entità fisiche, avvenimenti o \textbf{modelli (progetti)} di entità.
    \newpage
    \item \textbf{Associazioni}: Insieme di fatti binari, ad esempio associazione di un proprietario ad un auto.
    \item \textbf{Sottoclassi}: Sottoinsieme di una classe, come Studenti può esserlo di Persone.
\end{enumerate}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.6]{img/esempioRelazione1.png}
\end{figure}

\subsubsection{Associazioni e Cardinalità}

Formalmente le associazioni sono insiemi di coppie, quindi delle relazioni. Il tipo di freccetta che indica l'associazione
è detta cardinalità e corrisponde informalmente alla domanda:

\[ \text{"Per ogni elemento della classe A quanti della classe B?"} \]

Chiaramente va fatto sulla stessa direzione per entrambi i versi. Questo permette di risolvere le ambiguità causate dalla terminologia comune che è detta:

\[ \text{"Uno a Molti"} \:\: \text{oppure} \:\: \text{"Molti a Molti"} \]

che in qualche modo genera ambiguità perchè è come se si tenesse in conto solo di un verso. E' fondamentale ricordarsi quindi che la caratterizzazione della cardinalità di un associazione va
fatta in entrambi i versi.

Graficamente quindi avremo queste possibilità alle estremità delle associazioni:

\begin{enumerate}
    \item \textbf{Freccia Singola}: Per ogni elemento della classe di partenza è presente un elemento nella classe d'arrivo.
    \item \textbf{Freccia Doppia}: Per ogni elemento della classe di partenza sono presenti più elementi nella classe d'arrivo.
    \item \textbf{Trattino}: Nessun limite inferiore, di conseguenza per ogni elemento della classe di partenza può anche non essere presente alcun elemento nella classe d'arrivo.
\end{enumerate}

Esistono diverse notazioni grafiche, ma queste dispense fanno riferimento a quelle utilizzate durante gli esercizi del corso, quindi questa sarà la notazione comune di riferimento.

\newpage

\subsubsection{Associazioni Ternarie/con Attributi e Reificazione}

A volte le associazioni potrebbero complicarsi perchè:

\begin{enumerate}
    \item Potrebbero avere la \textbf{necessità} di avere degli \textbf{attributi}. Ad esempio in un caso di associazione tra Clienti e Stanze, la tariffa potrebbe non essere
    nè attributo di Clienti e nè di Stanze. In questo caso si assegna un \textbf{attributo} all'\textbf{associazione}.

    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.55]{img/associazioneAttributo.png}
    \end{figure}

    \item Potrei invece immaginare l'attributo come \textbf{vera} e \textbf{propria entità} di una specifica classe Tariffe. In quel caso non starei semplicemente dando 
    un attributo 

    
    all'associazione ma starei componendo un \textbf{associazione ternaria}.
    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.55]{img/associazioneTernaria.png}
    \end{figure}

\end{enumerate}

\paragraph{Reificazione} Si preferisce, nei casi illustrati sopra, semplificare la gestione 

dell'associazione tramite processo di reificazione, ossia la creazione di una classe di supporto aggiuntiva che permetta la gestione
regolare delle associazioni viste prima. Si illustrano le reificazioni delle associazioni viste sopra:

\vspace*{15px}

\begin{figure}[htbp]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{img/esempioReificazione1.png}
        \caption{Reificazione di Associazione con Attributo}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{img/esempioReificazione2.png}
        \caption{Reificazione di Associazione Ternaria}
    \end{minipage}
\end{figure}

Un dettaglio da notare è la \textbf{cardinalità} sulla nuova classe di supporto, infatti in \textbf{direzione} della \textbf{nuova classe} sarà presente un associazione di \textbf{uno a molti}.

\newpage

\subsubsection{Sottoclassi e Tipologie}

Una \textbf{sottoclasse} è un sottoinsieme di elementi di una classe, per i quali prevediamo di raccogliere ulteriori informazioni.

\[ \text{Studenti} \subseteq \text{Persone} \]
\[ \text{Libri Rari} \subseteq \text{Libri} \]

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.7]{img/notazioneGraficaSottoclassi.png}
    \caption{Notazione grafica di riferimento}
\end{figure}

\vspace*{10px}

Esistono varie tipologie di sottoclassi:

\vspace*{10px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.7]{img/tipiDiSottoclassi.png}
\end{figure}

\newpage

\subsection{Progettazione Logica}

Il \textbf{tipo} di \textbf{schema logico} presentato in questo corso è lo \textbf{schema relazionale}.

\vspace*{10px}

Basata su \textbf{schemi relazionali} detti informalmente \textbf{tabelle} di valori elementari con chiavi primarie:

\vspace*{5px}

\begin{center}
\begin{tabular}{ |c|c|c|c| }
    \hline
    \multicolumn{4}{|c|}{Impiegati} \\
    \hline
    \underline{IdImpiegato} & Nome & Stipendio & IdReparto* \\
    \hline
    232 & Lucia & 1200 & Y1 \\
    \hline
    143 & Luigi & 1500 & X2 \\
    \hline
\end{tabular}
\end{center}

\vspace*{5px}

In questo contesto \textbf{non esiste differenza} tra \textbf{attributi} ed \textbf{associazioni} dato che le chiavi
esterne permetteranno il \textbf{riferimento} ad \textbf{altre tabelle}.

\vspace*{5px}

\begin{center}
\begin{tabular}{ |c|c| }
    \hline
    \multicolumn{2}{|c|}{Reparti} \\
    \hline
    \underline{IdReparto} & Budget \\
    \hline
    Y1 & 100000 \\
    \hline
    X2 & 200000 \\
    \hline
\end{tabular}
\end{center}

\vspace*{5px}

Solitamente quindi si definisce \textbf{uno dei campi} della \textbf{tabella} come \textbf{chiave primaria}, ossia che \textbf{identifica} univocamente \textbf{la riga}. Invece il campo che permette la dereferenziazione univoca
di una riga in un altra tabella è detta \textbf{chiave esterna}, che corrisponde alla \textbf{chiave primaria} della \textbf{tabella esterna}.

\paragraph{Chiave e Superchiave Minimale} Definiamo \textbf{superchiave} qualsiasi \textbf{insieme di attributi} che \textbf{non} può \textbf{ripetersi} in \textbf{righe diverse}. Si definisce \textbf{chiave} una \textbf{superchiave minimale}, ossia un insieme di attributi a cui
non possiamo rimuovere alcun attributo. Sarà quindi scelta del progettista scegliere una \textbf{chiave primaria tra} tutte le \textbf{chiavi possibili}.

\subsubsection{Da Schema Concettuale a Schema Logico - Fasi}

Elenchiamo e descriviamo le fasi necessarie per il passaggio da schema \textbf{concettuale} a \textbf{logico}.

\begin{enumerate}
    \item Aggiungere una \textbf{chiave primaria} artificiale ad ogni collezione che ne ha bisogno.
    \begin{enumerate}
        \item Una chiave deve essere \textbf{immutabile}, \textbf{muta}, ossia non deve portare con se alcuna informazione, ed \textbf{invisibile} agli utenti.
    \end{enumerate}
    \item Tradurre le \textbf{associazioni} e le \textbf{inclusioni} in \textbf{chiavi esterne}.
    \begin{enumerate}
        \item Una associazione $1-N$ diventano \textbf{chiavi esterne}.
        \item Una associazione $M-N$ diventano \textbf{tabelle} con due chiavi esterne che puntano alle tabelle tra cui esiste l'associazione.
    \end{enumerate}
    \item Tradurre gli \textbf{attributi multivalore} in \textbf{tabelle}.
    \item \textbf{Appiattire} gli \textbf{attributi complessi}, ossia da struct a lista di parametri semplici.
\end{enumerate}

% Ti manca la parte su ATTRIBUTI MULTIVALORE e PARTIZIONE DI TABELLE, attendi le slide

\newpage

Nello schema logico le \textbf{sottoclassi} vengono rappresentate come \textbf{nuove tabelle}, con chiavi esterne in direzione
della superclasse.

\vspace*{10px}

\begin{center}
\begin{tabular}{ |c|c| }
    \hline
    \multicolumn{2}{|c|}{Persone} \\
    \hline
    \underline{PId} & Nome \\
    \hline
\end{tabular}
\end{center}

\makebox[0.95\textwidth][c]{
\begin{tabular}{ |c|c|c| }
    \hline
    \multicolumn{3}{|c|}{Impiegati} \\
    \hline
    Reparto & Stipendio & \underline{PId}* \\
    \hline
\end{tabular}
\hspace{0.2cm}
\begin{tabular}{ |c|c|c| }
    \hline
    \multicolumn{3}{|c|}{Consulenti} \\
    \hline
    Progetto & Tariffa & \underline{PId}* \\
    \hline
\end{tabular}
}

\vspace*{10px}

\section{Algebra Relazionale}

Insieme di operatori su relazioni che restituiscono altre relazioni. La forza di questo sistema di operazioni è che sono componibili, e formano successivamente ulteriori operazioni.

\subsection{Operatori Primitivi} Elenchiamo gli operatori primitivi:

\begin{enumerate}
    \item \textbf{Proiezione}: Data una tabella $R$, la funzione $\Pi_{A,B}(R)$ genera una nuova tabella in cui si mostrano solo le colonne $A,B$ della tabella $R$.
    \item \textbf{Restrizione}: Data una tabella $R$, la funzione $\rho_{cond}(R)$ genera una nuova tabella in cui si mostrano solo le righe in cui vale la condizione $cond$.
    \item \textbf{Unione}: Unione $R \: \cup \: S$, l'operazione può essere effettuata solo tra tabelle con lo stesso schema.
    \item \textbf{Differenza}: Differenza $R - S$, l'operazione può essere effettuata solo tra tabelle con lo stesso schema.
    \item \textbf{Prodotto Cartesiano}: Date due tabelle $R$ ed $S$, produce una nuova tabella con tutte le possibili n-uple formate dal prodotto delle due tabelle.
    \item \textbf{Ridenominazione}: Ridenominazione $\delta_{A \rightarrow B}(R)$, consiste informalmente nella ridenominazione dei campi che definiscono le colonne dello schema. Questo perchè altre operazioni binarie richiedono che le colonne di schemi diversi non abbiano gli stessi nomi.
\end{enumerate}

\subsection{Operatori Derivati} Elenchiamo gli operatori derivati:

\begin{enumerate}
    \item \textbf{Intersezione}: Date due tabelle $R$ ed $S$, restituisce le righe (tuple) che sono sia in $R$ sia in $S$, dunque è necessario che le due tabelle abbiano lo \textbf{stesso schema}.
    \[ R \: \cap \: S = R - (R - S) \]
    \item \textbf{Giunzione (Join)}: L'operazione $R \bowtie_{R.A = S.B} S$ combina le righe (tuple) di $R$ ed $S$ \textbf{solo quando} un attibuto A di R \textbf{è uguale} ad un attributo B di S. Questa operazione è derivata da:
    \[ R \bowtie_{R.A = S.B} S = \rho_{R.A = S.B} (R \times S) \]
    \item \textbf{Giunzione Naturale}: L'operazione $R \:v\: S$ è una giunzione automatica su tutti gli attributi che hanno lo stesso nome in entrambe le relazioni, quindi non sono specificate condizioni.
\end{enumerate}

\paragraph{Raggruppamento - Group By} Data una tabella $A$ si definisce uno dei suoi attributi $(A_{i})$ come \textbf{dimensione} e si genera una nuova tabella definendo funzioni $(f_{i})$ sulle altre colonne dette \textbf{misure}. Formalmente la definiamo quindi come $\Gamma_{\{A_i\}\{f_i\}}(R)$.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.55]{img/groupBy.png}
\end{figure}

\newpage

\section{Linguaggio SQL}

Linguaggio di interrogazione su calcolo di multiset basato su delle clausole specifiche:

\subsection{Clausole SQL}

\begin{enumerate}
    \item \textbf{SELECT}: Permette di selezionare specifici \textbf{campi della tabella} generata nella clausola FROM.
    \item \textbf{FROM}: Permette la combinazione di tabelle. In questa clausola abbiamo modo di utilizzare anche la clausola JOIN per unire più tabelle tramite specifici campi.
    Il modo più comune per l'utilizzo della JOIN è:
    \[ FROM \:\: Studenti \:\: s \:\: JOIN \:\: Esami \:\: e \:\: ON \:\: s.SId = e.SId \]
    \item \textbf{WHERE}: Permette di definire una restrizione sulle righe che soddisfano la condizione passata alla WHERE.
    Accade spesso di impostare una condizione per la WHERE con una sottoquery come parte dell'espressione di controllo. Esistono diversi tipi di sottoquery:
    \begin{enumerate}
        \item \textbf{Sottoquery restituisce un singolo valore}: La sottoquery calcola un valore (AVG, MAX, MIN...) e la WHERE utilizza questo valore nel confronto.
        \item \textbf{Sottoquery restituisce una colonna}: Vengono utilizzati operatori specifici come $IN, \: ANY, \: ALL$ con operando a destra il campo della colonna esterna e come operando a sinistra
        il risultato della sottoquery.
        \begin{lstlisting}
    SELECT name
    FROM employees
    WHERE dept_id IN (
        SELECT id
        FROM departments
        WHERE location = 'Rome'
        );
        \end{lstlisting}
        \item \textbf{Sottoquery correlata}: Sottoquery che viene valutata per ogni riga della tabella in questione, in modo tale che si possa confrontare un valore a tutti quelli di un campo della tabella.
        \begin{lstlisting}
    SELECT e.name, e.salary
    FROM employees AS e
    WHERE e.salary > (
        SELECT AVG(salary)
        FROM employees
        WHERE dept_id = e.dept_id
        );
        \end{lstlisting}
    \end{enumerate}
    \item \textbf{ORDER BY}: Permette l'ordinamento su un campo della tabella.
    \newpage
    \item \textbf{GROUP BY}: Si definisce come nell'algebra relazionale con delle \textit{dimensioni} e \textit{misure}. Le \textit{dimensioni} vanno riportate come argomenti della clausola \textbf{GROUP BY}, mentre le misure come \textit{argomenti} della \textbf{SELECT}.    
    \begin{lstlisting}
    SELECT s.Nome, AVG(e.Voto)
    FROM Studenti s, Esami e
    WHERE s.SId = e. SId
    GROUP BY s. SId
    \end{lstlisting}
    \vspace*{-15px}
    Quindi si genera per ogni gruppo una linea.
    \item \textbf{HAVING}: Questa clausola può essere applicata solo su dimensioni esplicite della GROUP BY e operazioni su attributi non dimensionali. Quindi la HAVING permette
    la cancellazione dei gruppi che violano la clausola HAVING.
    Quindi riassumendo tutte le clausole presentate in una pseudoquery:
    \begin{lstlisting}
    SELECT ... 
    FROM ...
    WHERE ... 
    GROUP BY ...
    HAVING ... 
    \end{lstlisting}
    \vspace*{-15px}
    Questa query eseguirà questi passi:
    \begin{enumerate}
        \item Esegue le clausole FROM e WHERE, calcolando quindi una tabella di partenza.
        \item Partiziona la tabella eseguendo il GROUP BY in base alle dimensioni fornite a questa clausola. Ogni gruppo diventa quindi una linea.
        \item Elimina i gruppi che violano le clausole passate alla HAVING.
        \item Proietta le colonne specificate nella clausola SELECT.
    \end{enumerate}
\end{enumerate}

\subsection{Valore NULL}

In SQL è ammesso il valore \textit{NULL} che definisce la non conoscenza di un valore di un campo. Questo però causa problemi in vari contesti, dato che andrà regolato il suo comportamento.
Il valore \textit{NULL} va letto come "non conosco il valore", quindi non si confronteranno i campi con un $= NULL$ ma esistono predicati appositi per verificare la presenza del \textit{NULL}, ad esempio $IS \: NULL$.

\vspace*{10px}

\subsection{Quantificazione Esistenziale/Universale in SQL}

\vspace*{10px}

\begin{enumerate}
    \item \textbf{Quantificazione Esistenziale}: In SQL è presente l'operatore EXISTS che ci permette di descrivere una condizione esistenziale scorrendo una tabella.
    \newpage
    In linguaggio logico avremmo così definito la quantificazione esistenziale:
    \[ \{ s.Nome \: | \: s \in Studenti \: \land \: \exists e \in Esami \: (e.SId = s.SId \land e.Voto = 27)  \} \]
    Come viene tradotta in SQL? Presentiamo un esempio utilizzando l'operatore EXISTS.
    \begin{lstlisting}
    SELECT s.Nome
    FROM Studenti s
    WHERE EXISTS 
        (SELECT *
        FROM Esami e
        WHERE e.SId = s.SId AND e.Voto > 27)
    \end{lstlisting}
    \item \textbf{Quantificazione Universale}: In SQL non esiste un operatore di quantificazione universale esplicito, quindi il modo più comune è quello di utilizzare un \textbf{NOT EXISTS} in combinazione con la \textbf{condizione negata alla query interna}. Presentiamo
    anche in questo caso un esempio di quantificazione universale in linguaggio matematico e successivamente in SQL.
    \vspace*{-5px}
    \[ \{ s.Nome \: | \: s \in Studenti \land \forall e \in Esami (e.SId = s.SId \land e.Voto = 27) \} \]
    In SQL questa viene tradotta in
    \begin{lstlisting}
    SELECT s.Nome
    FROM Studenti s
    WHERE NOT EXISTS
        (SELECT *
        FROM Esami e
        WHERE e.SId = s.SId AND e.Voto <> 30)
    \end{lstlisting}
    \vspace*{-20px}
    \paragraph{NULL e Quantificazione Universale} La quantificazione universale torna esito positivo sugli insiemi vuoti. Bisogna tener conto di questa caratteristica se non vogliamo nel risultato anche righe che erano nulle laddove si testava la condizione.
\end{enumerate}

\subsection{Outer Join}

Citiamo prima il comportamento di una \textbf{Inner Natural Join}:

\[
\begin{array}{c}
\text{R}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & B \\
\hline
1 & a \\
2 & b \\
3 & c \\
\hline
\end{array}
\end{array}
\quad
\text{NATURAL JOIN}
\quad
\begin{array}{c}
\text{S}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & C \\
\hline
1 & x \\
3 & y \\
5 & z \\
\hline
\end{array}
\end{array}
\quad
\Longrightarrow
\quad
\begin{array}{c}
\text{R} \bowtie \text{S}
\\[2mm]
\begin{array}{|c|c|c|}
\hline
A & B & C \\
\hline
1 & a & x \\
3 & c & y \\
\hline
\end{array}
\end{array}
\]

Si legano quindi solo in base alle chiavi esterne coincidenti.

\newpage

Diverso è invece il comportamento della Outer Join:

\begin{enumerate}
    \item \textbf{Left Outer Join}: Effettua una Natural Join e a questa aggiunge le righe della tabella a sinistra, aggiungendo nei \textit{NULL} dove necessario:
    \[
\begin{array}{c}
\text{R}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & B \\
\hline
1 & a \\
2 & b \\
3 & c \\
\hline
\end{array}
\end{array}
\quad
\text{LEFT JOIN}
\quad
\begin{array}{c}
\text{S}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & C \\
\hline
1 & x \\
3 & y \\
5 & z \\
\hline
\end{array}
\end{array}
\quad
\Longrightarrow
\quad
\begin{array}{c}
\text{R} \bowtie \text{S}
\\[2mm]
\begin{array}{|c|c|c|}
\hline
A & B & C \\
\hline
1 & a & x \\
3 & c & y \\
5 &   & z \\
\hline
\end{array}
\end{array}
\]

\vspace*{15px}

\item \textbf{Full Join}: Effettua una Natural Join e a questa aggiunge le righe di entrambe le tabelle, aggiungendo nei \textit{NULL} dove necessario:

    \[
\begin{array}{c}
\text{R}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & B \\
\hline
1 & a \\
2 & b \\
3 & c \\
\hline
\end{array}
\end{array}
\quad
\text{FULL JOIN}
\quad
\begin{array}{c}
\text{S}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & C \\
\hline
1 & x \\
3 & y \\
5 & z \\
\hline
\end{array}
\end{array}
\quad
\Longrightarrow
\quad
\begin{array}{c}
\text{R} \bowtie \text{S}
\\[2mm]
\begin{array}{|c|c|c|}
\hline
A & B & C \\
\hline
1 & a & x \\
2 & b &  \\
3 & c & y \\
5 &   & z \\

\hline
\end{array}
\end{array}
\]

\end{enumerate}

Questi tipi di Join ci permettono di manipolare risultati nulli, ad esempio:

\vspace*{15px}

\begin{enumerate}
    \item \textbf{Contare Esami di Ogni Studente, no Left Join}: Escludo chi non ha sostenuto alcun esame:
\begin{lstlisting}
    SELECT s.Nome, COUNT(*)
    FROM Studenti s JOIN Esami e USING (SId)
\end{lstlisting}
\vspace*{-15px}
    \item \textbf{Contare Esami di Ogni Studente, con Left Join}: Includo chi non ha sostenuto alcun esame:
\begin{lstlisting}
    SELECT s.Nome, COUNT(e.Voto)
    FROM Studenti s LEFT JOIN Esami e USING (SId)
    GROUP BY s.SId, s.Nome
\end{lstlisting}
\vspace*{-15px}
\end{enumerate}

\newpage

\subsection{Programmazione e SQL}

Si mostrano dei concetti più teorici riguardanti il SQL.

\subsubsection{Approcci Integrazione SQL}

Esistono vari approcci che permettono l'integrazione dell'SQL ai linguaggi di programmazione:

\begin{enumerate}
    \item \textbf{Linguaggio Integrato}: PL/SQL definito ad esempio da Oracle è SQL esteso fino a diventare un linguaggio completo, quindi viene compilato contemporaneamente sia l'SQL sia la parte di programmazione standard.
    \begin{itemize}
        \item \textbf{Vantaggio}: Viene compilato ed eseguito direttamente dal DBMS, permettendo operazioni come controlli per ruoli d'accesso in compilazione.
        \item Oracle PL/SQL permette la lettura di tipi del database e il loro utilizzo per la dichiarazione di variabili. In questo caso il codice SQL viene utilizzato come \textit{template}, interpretato secondo SQL e sostituito sintatticamente, per poi eseguire il linguaggio esterno.
    \end{itemize}

    \item \textbf{Linguaggio Convenzionale + API}: Si utilizza una libreria più un'interfaccia per l'interazione tra il linguaggio convenzionale e il DBMS.
    \begin{itemize}
        \item In questo contesto, il linguaggio convenzionale non effettua controlli statici 
        
        sull'SQL, poiché esso viene considerato come una \textbf{normale stringa}.
        \item \textbf{Vantaggio}: Le query vengono inviate al DBMS come stringhe.
        \item Tuttavia, non si risolve il disallineamento semantico (mismatch) dovuto a elementi come \texttt{NULL} o \texttt{MAX\_INT}.
    \end{itemize}

    \item \textbf{SQL Ospitato}: Approccio che utilizza costrutti come \texttt{begin SQL} ed \texttt{end SQL}, permettendo la condivisione di variabili tra, ad esempio, Python e SQL.
    \begin{itemize}
        \item Il precompilatore si occupa di compilare e di chiamare l'API, quindi i controlli a tempo di compilazione sono effettuati anche per l'SQL (differenza rilevante rispetto al caso precedente).
        \item Possono emergere problemi dovuti alla traduzione SQL, talvolta difficili da individuare.
        \item Possono sorgere inoltre problemi di differenza di espressività tra SQL (insiemi, record) e il linguaggio ospite.
    \end{itemize}
\end{enumerate}

\paragraph{Cursore/Buffer} Meccanismo che permette di scannerizzare elementi, è associato ad una espressione SQL e permette lo scorrimento di dati riga per riga con operazioni di \texttt{FETCH}.

\newpage

\subsubsection{Creazione Tabelle}

La definizione di una tabella in SQL è importante da saper leggere, anche se raramente viene richiesto di crearne una esplicitamente.

\vspace*{10px}

\begin{lstlisting}
    CREATE TABLE Employees( 
        Code CHAR(8) NOT NULL,
        Name CHAR(20),
        Birthyear INTEGER CHECK (Birthyear < 2005),
        Qualification CHAR(20) DEFAULT 'Employee',
        Supervisor CHAR(8),
        PRIMARY KEY pk_Employees (Code),
        FOREIGN KEY fk_Employees (Supervisor)
            REFERENCES Employees
    );

    CREATE TABLE Dependents(
        Name CHAR(20),
        Birthyear INTEGER,
        EmployeeCode CHAR(8),
        FOREIGN KEY fk_Dependents (EmployeeCode)
            REFERENCES Employees
    );
\end{lstlisting}

\vspace*{-10px}

\begin{itemize}
    \item Nella \textbf{foreign key} va specificato quale attributo punta a quale tabella.
    \item I comandi \texttt{DROP} e \texttt{ALTER} permettono rispettivamente di cancellare e modificare una tabella.
    \item \textbf{Vincolo di Foreign Key}: se un valore referenziato viene eliminato, è possibile definire comportamenti diversi, come:
    \begin{itemize}
        \item Impostare il valore a \texttt{NULL}.
        \item Usare \texttt{ON DELETE CASCADE}, che propaga la cancellazione.
    \end{itemize}
\end{itemize}

\subsubsection{Viste e Viste Materializzate}

\paragraph{Viste Materializzate}

Una vista materializzata è una \textbf{tabella fisica} costruita come risultato dell'esecuzione di una query su altre tabelle. 

\vspace*{10px}

\begin{lstlisting}
    CREATE TABLE Name SelectExpression;

    CREATE TABLE Supervisors AS
    SELECT Code, Name, Qualification, Salary
    FROM Employees
    WHERE Supervisor IS NULL;
\end{lstlisting}

\vspace*{-10px}

Questo approccio è utile quando i dati cambiano raramente, poiché le modifiche nella tabella originale non si riflettono automaticamente nella vista materializzata.

\newpage

\paragraph{Viste}

Le viste standard sono \textbf{viste virtuali}, cioè query memorizzate che non vengono eseguite finché non vengono richieste.

\vspace*{10px}

\begin{lstlisting}
    CREATE VIEW Name [(Attribute {, Attribute})]
    AS SelectExpression [WITH CHECK OPTION];

    CREATE VIEW Supervisors AS
    SELECT Code, Name, Qualification, Salary
    FROM Employees
    WHERE Supervisor IS NULL;
\end{lstlisting}

\vspace*{-10px}

Generalmente, le viste non vengono aggiornate direttamente perché non contengono dati reali.

\subsection{Motivazioni per l'uso delle viste}

\begin{itemize}
    \item Permettono di nascondere dati, garantendo \textbf{indipendenza logica}.
    \item Consentono \textbf{diverse rappresentazioni} degli stessi dati senza duplicazione.
    \item Possono \textbf{semplificare query} complesse.
    \begin{itemize}
        \item Ad esempio, quando si devono comporre più operazioni \texttt{GROUP BY}, è possibile costruire una vista intermedia.
        \item Con SQL moderno è possibile usare subquery nella \texttt{FROM}, quindi l'uso delle viste per questo scopo è meno frequente ma resta utile per chiarezza.
    \end{itemize}
\end{itemize}

\subsubsection{Procedure e Funzioni}

Alcuni DBMS permettono di definire procedure e funzioni interne. Un esempio è il linguaggio \texttt{PL/SQL} di Oracle.

\vspace*{10px}

\begin{lstlisting}
    CREATE FUNCTION countStudents IS
    DECLARE
        total INTEGER;
    BEGIN
        SELECT COUNT(*) INTO total FROM STUDENTI;
        RETURN (total);
    END;
\end{lstlisting}

\newpage

\subsubsection{Trigger}

I \textbf{trigger} sono funzioni che vengono eseguite automaticamente al verificarsi di un determinato evento (ad esempio prima o dopo un \texttt{INSERT}, \texttt{UPDATE} o \texttt{DELETE}).

\vspace*{10px}

\begin{lstlisting}
    CREATE TRIGGER SalaryCheck
    BEFORE INSERT ON Employees
    DECLARE
        AvgSalary FLOAT;
    BEGIN
        SELECT AVG(Salary) INTO AvgSalary
        FROM Employees
        WHERE Department = :new.Department;

        IF :new.Salary > 2 * AvgSalary THEN
            RAISE_APPLICATION_ERROR(-2061, 'Salary too high');
        END IF;
    END;
\end{lstlisting}

\vspace*{-10px}

\begin{itemize}
    \item I trigger sono usati quando i vincoli coinvolgono \textbf{più tabelle}, poiché una semplice clausola \texttt{CHECK} opera solo sulla tupla corrente.
    \item Possono essere usati per mantenere valori derivati o contatori aggiornati automaticamente.
    \item I trigger possono vincolare anche operazioni di \texttt{DELETE}, mentre \texttt{CHECK} non può farlo.
\end{itemize}

\subsubsection{Access Control nel Database}

Il creatore di un database ha permessi completi: \texttt{CREATE}, \texttt{ALTER}, \texttt{DROP}.  
Può inoltre concedere permessi ad altri utenti, anche a livello di singola colonna.

\vspace*{10px}

\begin{lstlisting}
    GRANT Privileges ON Object
    TO Users [ WITH GRANT OPTION ];
\end{lstlisting}

\vspace*{-10px}

\paragraph{Indici}

Gli indici sono strutture dati utilizzate per velocizzare l'accesso ai dati nelle query.  
Tuttavia, un numero eccessivo di indici rallenta \textbf{inserimenti, modifiche e cancellazioni}, poiché anche gli indici devono essere aggiornati.

\paragraph{Catalogo - Metadata}

Il \textbf{catalogo} (o dizionario dati) contiene metadati sul database.  
Ad esempio:
\begin{itemize}
    \item Elenco delle tabelle del DB
    \item Tipi degli attributi
    \item Vincoli definiti
\end{itemize}

Ogni riga nella \emph{tabella delle tabelle} rappresenta una tabella del database.

\newpage

\section{Teoria della Normalizzazione}

La teoria della normalizzazione permette di definire equivalenze tra schemi relazionali ed anomalie in essi.

\paragraph{Buona Progettazione di Schemi Relazionali} Si basa sull'analisi di quattro proprietà:

\begin{itemize}
    \item \textbf{Semantica degli Attribuiti}: Progettazione mirata all'utilizzo di attributi che appartengano solo alla classe di quello schema.
    \item \textbf{Ridondanza}: Progettazione mirata a schemi in cui non siano presenti anomalie in caso di inserimento, cancellazione o modifica.
    \item \textbf{Valori Nulli}: Per quanto possibile, si progettano schemi in modo tale da evitare attributi che possono essere frequentemente nulli.
    \item \textbf{Tuple Spurie}: Le giunzioni tra schemi non dovrebbero mai generare tuple spurie.
\end{itemize}

\paragraph{Obiettivi della Teoria Normalizzazione} Fornire strumenti formali per la progettazione di basi di dati che non presentino anomalie, e grazie all'equivalenza,
permettere anche la ricerca di uno schema equivalente ad uno già esistente ma senza anomalie. I \textbf{problemi} quindi di cui si occupa la \textbf{teoria della normalizzazione} sono:

\begin{itemize}
    \item \textbf{Equivalenza tra Schemi}: Definire quando due schemi siano equivalenti.
    \item \textbf{Qualità degli Schemi}: Definire criteri di bontà di schemi.
    \item \textbf{Trasformazione di Schemi}: Definire metodi algoritmici per ottenere da uno schema un altro schema che sia migliore di quello di partenza.
\end{itemize}

\paragraph{Schema di Relazione Universale} Definiamo formalmente l'insieme universo degli attributi. Lo schema di relazione universale $U$ di una base di dati relazionale ha come attributi l'unione
degli attributi di tutte le relazioni della base di dati.

\paragraph{Notazione} Definiamo un po' di notazione utile:

\begin{itemize}
    \item $A,B,C,A_{1},A_{2}$ indicano singoli attributi.
    \item $T,X,Y,X_{1}$ indicano insiemi di attributi.
    \item Potenziali Abbreviazioni:
    \begin{itemize}
        \item $XY$ è abbreviazione per $X \cup Y$.
        \item $AB$ è abbreviazione per $\{ A,B \}$.
        \item $XA$ è abbreviazione per $X \cup \{A\}$.
    \end{itemize}
    \item $R(T)$ è un generico schema, $r$ è una sua istanza e $t$ è una n-upla di $r$.
    \item Se $X \subseteq T$ allora $t[X]$ indica l'n-upla ottenuta da $t$ considerando solo gli attributi in $X$.
\end{itemize}

\newpage

\subsection{Dipendenze Funzionali}

Vogliamo formalizzare la \textbf{nozione di schema senza anomalie}, occorre quindi \textbf{descrivere formalmente} la \textbf{semantica} dei dati in una istanza dello schema relazionale. Quindi definiamo come \textbf{aspetto estensionale} quello che si riferisce al \textbf{contenuto dei dati},
ed \textbf{aspetto intensionale} quello che si riferisce al \textbf{significato dei dati}.

\subsubsection{Definizione Formale di Dipendenza Funzionale e Significato}

Dato uno schema $R(T)$ e $X,Y \subseteq T$, una dipendenza funzionale \texttt{DF} è un \textbf{vincolo} su $R$ del tipo $X \rightarrow Y$, ossia
\vspace*{-2px}
\[ X \: \text{determina funzionalmente} \: Y \]
\[\text{o in maniera equivalente}\]
\[ Y \: \text{è determinata funzionalmente da} \: X \]

se vale che per ogni $r$ istanza valida di $R$ un valore di $X$ determina in modo univoco un valore di $Y$, formalmente definito come:

\begin{itemize}
    \item $\forall r$ istanza valida di $R$.
    \item $\forall t_{1}, t_{2} \in r \: \text{vale che} \: t_{1}[X] = t_{2}[X] \Rightarrow t_{1}[Y] = t_{2}[Y] $
\end{itemize}

\paragraph{Spiegazione Definizione} In un istanza $r$ di $R(T)$ è soddisfatta la dipendenza $X \rightarrow Y$ se per ogni coppia
di n-uple $t_1, t_2 \in r$  è vero che $t_{1}[X] = t_{2}[X] \Rightarrow t_{1}[Y] = t_{2}[Y]$.

\paragraph{Caratteristiche Dipendenze Funzionali} Queste dipendenze sono definite solo 

all'interno di uno schema di relazione e non possono esistere tra attributi di schemi diversi. Oltre a questo sono proprietà intensionali, sono legate alla semantica assegnata all'attributo e non possono quindi essere
inferite sulla base dell'osservazione di alcune istanze della relazione.

\subsubsection{Definizioni Formali di Chiave, Superchiave e Chiave Primaria}

Dato un insieme $K$ di attributi per uno schema di relazione $r$:

\begin{itemize}
    \item \textbf{Superchiave}: L'insieme $K$ è superchiave se \textbf{non contiene} due n-uple distinte $t_{1}, t_{2}$ con $t_{1}[K] = t_{2}[K]$. Quindi l'insieme di attributi $K$ identifica univocamente una n-upla.
    \item \textbf{Chiave}: L'insieme $K$ è \textbf{chiave se è superchiave minimale}, ossia non contiene un altra superchiave al suo interno. Quindi se eliminassimo degli attributi questa non sarebbe più una superchiave.
    \item \textbf{Chiave Primaria}: Una delle chiavi dello schema di relazione, solitamente si preferisce quella con meno attributi.
\end{itemize}

\newpage

\subsubsection{Dipendenza Funzionale e Soddisfacibilità su Istanze}

Introduciamo un nuovo operatore $\models$ (soddisfa):

\begin{itemize}
  \item un'istanza $r_0$ di $R$ \textbf{soddisfa} la DF $X \to Y$
  se:
  \[
  r_0 \models X \to Y
  \]
  cioè se:
  \[
  \forall t_1, t_2 \in r_0,\ t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y]
  \]
  \item un istanza $r_0$ \textbf{soddisfa} un insieme $F$ di $DF$ se:
  \[ \forall X \to Y \in F vale r_0 \models X \to Y \]
  cioè se
  \[ r_0 \models X \to Y \: \text{se} \: \forall t_1,t_2 \in r_0 \: \text{vale che} \: t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y] \]
\end{itemize}

\subsubsection{Dipendenze Funzionali Atomiche e Banali}

\begin{itemize}
    \item \textbf{Atomica}: Ogni dipendenza del tipo $X \to A_1 A_2 \cdots A_n$ è scomponibile in $X \to A_1, X \to A_2 \cdots, X \to A_n$. La seconda tipologia è detta \textbf{atomica}.
    \item \textbf{Banale}: Una dipendenza del tipo $Progetto \to Progetto$ è detta \textbf{banale}.
\end{itemize}

\subsection{Utilizzo di Dipendenze Funzionali}

Vogliamo utilizzare uno schema di relazione e le sue dipendenze per ricavarne altre, quindi definiamo da adesso in poi lo schema come $R(T,F)$ con $F$ insieme di
dipendenze funzionali su $T$.

\subsubsection{Derivazione di Dipendenze Funzionali}

Basandoci sulla definizione data prima di soddisfacibilità di istanze, dato $R(T,F)$ diciamo che $F \models X \to Y$ se ogni istanza $r \in R(T)$ che soddisfa $F$ soddisfa anche $X \to Y$.

\subsubsection{Assiomatizzazione delle Dipendenze Funzionali} Sia $RI$ un insieme di regole di inferenza per $F$, utilizzeremo $RI$ per derivare altre dipendenze funzionali a partire da $F$.

Indichiamo con $F \vdash X \to Y$ il fatto che $X \to Y$ sia derivabile da $F$ usando $RI$.

\paragraph{Correttezza e Completezza di un Insieme di Regole di Inferenza} Esistono due proprietà principali di un sistema d'inferenza:

\begin{itemize}
    \item \textbf{Correttezza}: L'insieme $RI$ se $F \vdash X \to Y$ implica $F \models X \to Y$.
    \item \textbf{Completezza}: L'insieme $RI$ se $F \models X \to Y$ implica $F \vdash X \to Y$.
\end{itemize}

\newpage

\subsubsection{Assiomi di Armstrong e Derivazioni}

Gli assiomi di Armstrong sono l'insieme noto corretto e completo di regole di inferenza. Elenchiamo queste regole:

\begin{itemize}
    \item \textbf{Riflessività}: se $Y \subseteq X$ allora $X \to Y$.
    \item \textbf{Arricchimento}: se $X \to Y$, $Z \subseteq T$ allora $XZ \to YZ$.
    \item \textbf{Transitività}: se $X \to Y$, $Y \to Z$ allora $X \to Z$
\end{itemize}

Da queste possiamo derivarne altre:

\begin{itemize}
    \item \textbf{Unione}: $\{ X \to Y, X \to Z \} \vdash X \to YZ$
    \item \textbf{Decomposizione}: $\{ X \to YZ \} \vdash X \to Y$
    \item \textbf{Indebolimento}: $\{ X \to Y \} \vdash XZ \to Y$
    \item \textbf{Identità}: $\{ \} \vdash X \to Y $
\end{itemize}

\paragraph{Teorema di Correttezza e Completezza Assiomi di Armstrong} Gli assiomi di Armstrong sono corretti e completi. Attraverso gli assiomi stessi si può mostrare l'equivalenza tra
implicazione logica $\models$ e derivazione $\vdash$. Questo perchè se una dipendenza è derivabile con gli assiomi di Armstrong allora è anche implicata logicamente (per la correttezza degli assiomi), e viceversa se una dipendenza
è implicata logicamente allora è anche derivabile dagli assiomi (per completezza degli assiomi).

\begin{itemize}
    \item \textbf{Correttezza}: $\forall f \:\: F \vdash f \Rightarrow F \models f$
    \item \textbf{Completezza}: $\forall f \:\: F \models f \Rightarrow F \vdash f$
\end{itemize}

\subsubsection{Chiusura di un Insieme}

Dato un insieme $F$ di $DF$ la chiusura di $F$ è $F^{+} = \{ X \to Y \: | \: F \vdash X \to Y \}$. 

\vspace*{10px}

Contestualizzando ad una $R(T,F)$ data con $X \subseteq T$ la chiusura di $X$ rispetto ad $F$ denotata con $X_{F}^{+}$ è \[ X_{F}^{+} = \{ A_{i} \in T \: | \: F \vdash X \to A_{i} \} \]

\subsubsection{Algoritmo della Chiusura Lenta}

Vogliamo decidere, data una $DF$, se questa appartiene a $F^+$. Applicare ripetutamente gli assiomi di Armstrong ha una complessità esponenziale rispetto al numero di attributi dello schema. Si preferisce quindi utilizzare un algoritmo basato su uno specifico teorema.

\paragraph{Teorema} La $DF: X \to Y$ è derivabile da $F$ se e solo se $Y$ è sottoinsieme della chiusura di $X$ rispetto ad $F$ formalmente definito come:

\[ F \vdash X \to Y \Leftrightarrow Y \subseteq X_{F}^{+} \]

\newpage

\paragraph{Definizione di Chiavi tramite Dipendenze e Chiusura}

\begin{itemize}
    \item \textbf{Superchiave}: Dato lo schema $R(T,F)$, un insieme di attributi $W \subseteq T$ è una \textbf{superchiave} di $R$ se $W \to T \in F^{+}$.
    \item \textbf{Chiave}: Dato lo schema $R(T,F)$, un insieme di attributi $W \subseteq T$ è una \textbf{chiave} di $R$ se $W$ è una superchiave e non esiste un sottoinsieme stretto di $W$ che sia superchiave di $R$.
    \item \textbf{Attributo Primo}: Dato lo schema $R(T,F)$, un attributo $A \in T$ si dice \textbf{attributo primo} se e solo se appartiene ad almeno una chiave, altrimenti si dice non primo.
\end{itemize}

\paragraph{Proprietà Interessanti per Ricerca di Chiavi} L'algoritmo per trovare tutte le chiavi si basa su due proprietà:

\begin{itemize}
    \item Se un attributo $A$ di $T$ \textbf{non appare a destra} di alcuna dipendenza in $F$, allora $A$ \textbf{appartiene} ad ogni chiave di $R$, altrimenti non può essere determinato.
    \item Se un attributo $A$ di $T$ \textbf{appare a destra} di qualche dipendenza in $F$, \textbf{ma non appare a sinistra} di alcuna dipendenza non banale, allora A \textbf{non appartiene ad alcuna chiave}.
\end{itemize}

\paragraph{Esempio di Derivazione} Dato $F = \{ DB \to E, B \to C, A \to B \}$ trovare $(AD)^+$:

\[ X^+ = AD = ADB = ADBE = ADBEC \]

Quindi data questa produzione, possiamo ad esempio notare che $AD$ è superchiave perchè contiene tutti gli attributi ed $A$ \textbf{non è superchiave} perchè la produzione $A \to B, A \to BC$ si ferma.

\subsection{Copertura Canonica e Decomposizione}

L'obiettivo di questo sottocapitolo è quello di definire schemi che siano equivalenti, dopo operazioni di decomposizione.

\paragraph{Definizione Copertura/Equivalenza} Due insiemi di $DF$, $F$ e $G$ sullo schema $R$ sono \textbf{equivalenti} $F \equiv G$ se e solo se $F^+ = G^+$. Se vale questa condizione allora si dice che $F$ è \textbf{copertura} di $G$ e viceversa.

\subsubsection{Definizioni Formali di Attributo Estraneo e Dipendenza Ridondante}

\begin{itemize}
    \item \textbf{Definizione Copertura Canonica}: Data una $X \to Y \in F$, si dice che $X$ contiene un \textbf{attributo estraneo} se e solo se $(X - \{ A_i \}) \to Y \in F^+$, quindi vale 
    
    che $F \vdash (X - {A_{i}}) \to Y $.
    \item \textbf{Dipendenza Funzionale Ridondante}: $X \to Y$ è detta ridondante se e solo se $(F - \{ X \to Y \})^+ = F^+$ o equivalentemente $F - \{ X \to Y \} \vdash X \to Y$.
\end{itemize}

\newpage

\subsubsection{Definizione Copertura Canonica}

$F$ è detta \textbf{copertura canonica} se rispetta queste condizioni:

\begin{itemize}
    \item Tutte le dipendenze $DF$ in $F$ sono atomiche.
    \item Non esistono attributi estranei.
    \item Nessuna dipendenza in $F$ è ridondante.
\end{itemize}

Sulla base di questa definizione è possibile definire il seguente teorema:

\paragraph{Teorema} Per ogni insieme di dipendenze $F$ esiste una copertura canonica.

\vspace*{10px}

Quindi avendo un teorema per l'esistenza di copertura canonica, possiamo definire un algoritmo per calcolare una copertura canonica, che attraversa tre fasi per validare le proprietà richieste dalla definizione di copertura canonica:

\begin{itemize}
    \item Trasformare tutte le dipendenze in forma atomica.
    \item Eliminare tutti gli attributi canonici.
    \item Eliminare tutte le dipendenze ridondanti.
\end{itemize}

\paragraph{Tipi di Ridondanza} Esistono due tipi differenti di ridondanza:

\begin{itemize}
    \item \textbf{Ridondanza Concettuale}: Non esistono informazioni duplicate ma informazioni che sono ricavabili da altre già presenti nella base di dati.
    \item \textbf{Ridondanza Logica}: Esistono informazioni duplicate.
\end{itemize}

\subsubsection{Definizione di Decomposizione di Schemi e Proprietà Attese - Conservazione Dati e Dipendenze}

Dato uno schema $R(T)$, $\rho\{ R_1(T_1), \cdots, R_k(T_k) \}$ è una \textbf{decomposizione} di $R$ se e solo se $T_1 \cup \cdots \cup T_k = T$.

\paragraph{Proprietà Attese} Dopo una buona operazione di decomposizione ci aspettiamo che siano rispettate due condizioni:

\begin{itemize}
    \item \textbf{Conservazione dei Dati}: $\rho\{ R_1(T_1), \cdots, R_k(T_k) \}$ è una decomposizione di uno schema $R(T)$ che preserva i dati se e solo se per ogni istanza valida $r$ di $R$ vale che:
    \[ r = (\pi_{T1}r) \bowtie (\pi_{T2}r) \bowtie \cdots \bowtie (\pi_{Tk}r) \]
    Quindi dalla definizione di giunzione naturale scaturisce questo teorema:
    \begin{itemize}
        \item \textbf{Teorema}: Se $\rho = \{ R_1(T_1), \cdots, R_k(T_k) \}$ è una decomposizione di $R(T)$, allora per ogni istanza $r$ di $R$ vale che $r \subseteq (\pi_{T1}r) \bowtie (\pi_{T2}r) \bowtie \cdots \bowtie (\pi_{Tk}r)$.
    \end{itemize}
    Quindi il vincolo $=$ della definizione non lascia spazio ad altre n-uple, che sono invece potenzialmente presenti nel teorema che si basa sul operatore $\subseteq$. Quindi se la decomposizione avviene senza perdite di dati allora questo vuol dire che non verrà generata alcuna n-upla spuria.
    \newpage
    \paragraph{Teorema Informale Decomposizione Senza Perdite} Se l'insieme di attributi comuni alle due relazioni $X_{1} \cap X_{2}$ \textbf{è chiave} per \textbf{almeno una delle due relazioni} decomposte allora la \textbf{decomposizione} è \textbf{senza perdite}. Nel caso binario questo diventa:
    \begin{itemize}
        \item Sia $R(T,F)$ uno schema di relazione, la decomposizione $\rho = \{ R_{1}(T_1), R_{2}(T_2) \}$ preserva i dati se e solo se $T_1 \cap T_2 \to T_1 \in F^+$ oppure $T_1 \cap T_2 \to T_2 \in F^+$.
    \end{itemize}
    \item \textbf{Preservazione di Dipendenze}: Dato lo schema $R(T,F)$, e $T_1 \subseteq T$, la proiezione di $F$ su $T_1$ è definita come:
    \[ \pi_{T1}(F) = \{ X \to Y \in F^+ \: | \: XY \subseteq T_1 \} \]
    Informalmente stiamo quindi dicendo che una decomposizione preserva le \textbf{dipendenze} se \textbf{ciascuna} di queste dello schema originario coinvolge attributi che compaiono \textbf{tutti insieme in uno degli schemi decomposti}.
\end{itemize}

\vspace*{10px}

\subsection{Forme Normali}

Una forma normale è una proprietà di una base di dati relazionale che ne garantisce la qualità, solitamente quando una relazione non è normalizzata presenta ridondanze o si presta a comportamenti poco desiderabili durante gli aggiornamenti.

\paragraph{Tipi di Forme Normali} Ogni tipo di forma normale definisce specifici vincoli:

\begin{itemize}
    \item \textbf{1FN (Prima Forma Normale)}: Impone una restrizione sul tipo di una relazione: ogni attributo ha un tipo elementare.
    \item \textbf{2FN, 3FN e BCNF}: Impongono restrizioni sulle dipendenze e la Boyce-Codd BCNF è la più naturale e restrittiva.
\end{itemize}

\vspace*{10px}

\subsubsection{BCNF - Forma Normale di Boyce-Codd}

Una relazione $r$ si dice in BCNF se \textbf{per ogni dipendenza funzionale} non banale del tipo $X \to Y$ definita su essa, $X$ contiene una chiave $K$ di $r$, ovvero \textbf{$X$ è superchiave}.

\paragraph{Definizione Formale} $R(T,F)$ è in BCNF $\Leftrightarrow$ per ogni $X \to A \in F^+$ non banale, ossia vale che $A \notin X$ quindi $X$ è una superchiave.

\paragraph{Teorema} $R(T,F)$ è in BCNF $\Leftrightarrow$ per ogni $X \to A \in F$ non banale vale che $X$ è superchiave.

\paragraph{Corollario} $R(T,F)$ con $F$ in copertura canonica è in BCNF $\Leftrightarrow$ per ogni $DF$ atomica non banale $X \to A \in F$ vale che $X$ è una superchiave.

\newpage

\subsubsection{Algoritmo di Analisi}

Questo algoritmo prende in input una relazione $R(T,F)$ con $F$ copertura canonica e produce in output un $\rho = \{ R_1, R_2, R_m \}$ decomposizione in BCNF che preserva i dati. Possiamo definirne uno pseudocodice:

\begin{Verbatim}[commandchars=\\\{\}]
while esiste in \(\rho\) una \(Ri(Ti, Fi)\) non in BCNF per la DF \( X \to A \)
    //incrememta contatore relazioni
    n=n+1
    //chiusura di X
    Ta = X+
    //proiezione DF rispetto a Ta
    Fa = \(\pi\) Ta(Fi)
    //rimozione da attrivuti non in X ma nella sua chiusura
    //riaggiunta X alla fine
    Tb = Ti - X+ + X
    //rimuove R non BCNF per \( X \to A \) e inserisce quelle corrette
    \( \rho \) = \(\rho - Ri + {Ri <Ta,Fa>, Rn<Tb,Fb>} \)
\end{Verbatim}

Questo algoritmo \textbf{preserva i dati ma non necessariamente le dipendenze}.

In alcune occasioni bisogna ricorrere a forme di normalizzazione indebolita. Mostriamo ad esempio la 3FN che consente di ottenere decomposizioni senza perdite e che preservano tutte le dipendenze.

\subsubsection{3FN - Terza Forma Normale}

Rilassiamo il vincolo della definizione precedente mettendo il vincolo della BCNF in $XOR$ con la possibilità di $A$ di essere \textbf{attributo primo}.

\paragraph{Definizione} $R(T,F)$ è in 3FN se per ogni $X \to A \in F^{+}$, con $A \notin X$ vale che $X$ è una \textbf{superchiave} \textbf{oppure} $A$ è \textbf{attributo primo}.

\paragraph{Teorema} $R(T,F)$ è in 3FN se per ogni $X \to A \in F$ non banale vale che $X$ è una superchiave oppure A è primo, ossia è contenuto in almeno una chiave.

\paragraph{Esistenza 3FN e Caratteristiche} Elenchiamo alcune caratteristiche della 3FN:
\begin{itemize}
    \item \textbf{Esistenze e Proprietà Garantite}: Ogni schema del tipo $R(T,F)$ \textbf{ammette sempre} una decomposizione che \textbf{preserva dati}, \textbf{dipendenze ed è in 3FN}.
    \item \textbf{Tempo Ottenimento 3FN}: La decomposizione 3FN può essere ottenuta in tempo polinomiale.
    \item \textbf{Meno Restrizione}: Essendo meno restrittiva, la 3FN accetta anche schemi che presentano anomalie, in particolare la 3FN \textbf{tollera le ridondanze sui dati}.
\end{itemize}

\newpage

\subsubsection{Algoritmo di Sintesi}

L'interesse per la 3FN è derivato dal fatto che ci permette di \textbf{decomporre qualsiasi schema} in un \textbf{insieme di relazioni in 3FN} tramite un algoritmo semplice e \textbf{preservando dati e dipendenze}.

\vspace*{10px}

In maniera approssimata potremmo quindi dire che l'idea dell'algoritmo sia quella di partizionare una copertura canonica $G$ data in gruppi $G_{i}$ tali che tutte le dipendenze in ogni $G_{i}$ abbiano la stessa parte sinistra. Quindi da ogni $G_{i}$ si definisce uno schema di relazione composto da tutti gli attributi che vi appaiono, la cui chiave, detta chiave sintetizzata, è la parte sinistra comune.

\paragraph{Formalizzazione Algoritmo di Sintesi in Versione Base} Definiamo l'effettivo algoritmo, descrivendolo a passi:

\begin{itemize}
    \item \textbf{Input}: Insieme $R$ di attributi ed un insieme $F$ di dipendenze su $R$.
    \item \textbf{Output}: Decomposizione $\rho = \{ S_{i} \}_{i=1 \cdots n}$ di $R$ tale che \textbf{preservi dati e dipendenze} ed ogni $S_{i}$ sia in 3FN rispetto alle proiezioni di $F$ su $S_{i}$.
    \item \textbf{Fasi}: L'algoritmo è caratterizzato da queste fasi:
    \begin{enumerate}
        \item Trova una copertura canonica $G$ di $F$ e poni $\rho = \{ \: \}$.
        \item Sostituisce in $G$ ogni insieme $X \to A_1, \cdots, X \to A_{h}$ di dipendenze con lo stesso determinante, con la dipendenza $X \to A_1 \cdots A_h$.
        \item Per ogni dipendenza $X \to Y$ in $G$, metti uno schema con attributi $XY$ in $\rho$.
        \item Elimina ogni schema di $\rho$ contenuto in un altro schema di $\rho$.
        \item Se la decomposizione \textbf{non} contiene alcuno schema i cui attributi costituiscano una superchiave per $R$, aggiungi ad essa lo schema con attributi $W$, con $W$ una chiave di $R$.
    \end{enumerate}
\end{itemize}

\newpage

\section{Realizzazione di un DBMS}

\subsection{Architettura dei DBMS e Gestione della Memoria}

Lo studio della realizzazione dei DBMS è indispensabile per utilizzare tali sistemi in modo efficace. È necessario conoscere l'architettura dei DBMS relazionali centralizzati e le tecniche utilizzate per implementare le funzionalità essenziali, come la gestione dei dati, delle interrogazioni, della concorrenza e dell'affidabilità.

\subsubsection{Gerarchia delle Memorie e Implicazioni per i DBMS}

La memoria di un sistema di calcolo è organizzata in una gerarchia. Ai livelli più alti si trovano memorie di piccola dimensione, molto veloci e costose; scendendo lungo la gerarchia, la dimensione aumenta mentre velocità e costo diminuiscono.

Le prestazioni di una memoria sono misurate in termini di tempo di accesso, dato dalla somma della latenza (tempo per accedere al primo byte) e del tempo di trasferimento dei dati:
$$
\text{Tempo di accesso} = \text{latenza} + \frac{\text{dimensione dati da trasferire}}{\text{velocità di trasferimento}}
$$
A causa delle loro grandi dimensioni, i database (DB) risiedono normalmente su dischi o altri tipi di dispositivi. I dati devono essere trasferiti in memoria centrale per l'elaborazione da parte del DBMS.

\paragraph{Trasferimento Dati e Ottimizzazione}
Il trasferimento dei dati non avviene a livello di singole tuple, ma in termini di \textbf{blocchi} (o \textbf{pagine}, quando sono in memoria centrale).
Poiché le operazioni di I/O (Input/Output) spesso costituiscono il \textbf{collo di bottiglia} del sistema, è cruciale ottimizzare l'implementazione fisica del DB attraverso:
\begin{itemize}
    \item Organizzazione efficiente delle tuple su disco.
    \item Strutture di accesso efficienti.
    \item Gestione efficiente dei buffer in memoria.
    \item Strategie di esecuzione efficienti per le query.
\end{itemize}

\paragraph{Struttura degli Hard Disk}
Un hard disk (HD) è un dispositivo elettro-meccanico che conserva informazioni magnetiche su un supporto rotante (piatto). I dischi metallici ruotano a velocità costante e le testine di lettura si muovono radialmente. Una traccia è suddivisa in settori di dimensione fissa, raggruppati logicamente in \textbf{blocchi}, che sono l'unità di trasferimento.
Trasferire un blocco richiede un tempo di posizionamento delle testine (seek time), un tempo di latenza rotazionale e il tempo di trasferimento vero e proprio (che è spesso trascurabile).

\paragraph{Pagine e Località}
Un blocco (o pagina) è una sequenza contigua di settori su una traccia, ed è l'unità di I/O utilizzata dal DBMS. La dimensione tipica di una pagina varia da 4 a 64 KB.
\begin{itemize}
    \item Pagine piccole comportano un maggior numero di operazioni di I/O.
\newpage
    \item Pagine grandi aumentano la frammentazione interna (pagine parzialmente riempite).
\end{itemize}
\paragraph{Importanza Località} L'importanza della località è critica, leggere un file memorizzato in settori consecutivi è estremamente più veloce rispetto a leggerlo da blocchi distribuiti a caso.

\subsubsection{Gestore della Memoria Permanente e del Buffer}

\paragraph{Gestore Memoria Permanente}
Fornisce un'astrazione della memoria permanente in termini di file logici di pagine fisiche (blocchi), nascondendo i dettagli dei dischi e del sistema operativo.

\paragraph{Gestore del Buffer}
Si occupa del trasferimento delle pagine tra la memoria temporanea (\textbf{Buffer Pool}) e la memoria permanente. Offre agli altri livelli del DBMS una visione della memoria permanente come un insieme di pagine utilizzabili nel buffer, astraendo da quando esse vengono trasferite.

Nel Buffer Pool, ogni pagina ha informazioni associate:
\begin{itemize}
    \item \textbf{NumeroSpilli (Pin count)}: Contatore incrementato quando una pagina viene richiesta dal DBMS (\texttt{getAndPinPage}) e decrementato quando viene rilasciata (\texttt{unPinPage}). Fino a quando il pin count è maggiore di zero, la pagina non può essere rimpiazzata.
    \item \textbf{SeModificata (dirty/non dirty)}: Indica se la pagina è stata modificata (\textit{dirty} o "sporca"). Se una pagina è \textit{dirty}, deve essere riscritta su disco (\texttt{flushPage}) prima di essere rimpiazzata.
\end{itemize}

\paragraph{Politiche di Rimpiazzamento}
La politica comune nei sistemi operativi è \textbf{LRU} (Least Recently Used). Tuttavia, nei DBMS, LRU non è sempre la scelta migliore perché il "pattern di accesso" ai dati è spesso noto. Ad esempio, per alcuni algoritmi di \textit{join}, la politica migliore può essere \textbf{MRU} (Most Recently Used), che rimpiazza la pagina utilizzata più di recente.
La bontà di una politica è misurata dall'\textbf{hit ratio}, ovvero la frazione di richieste che non provocano un'operazione di I/O.

\subsubsection{Strutture e Organizzazioni di Memorizzazione}

\paragraph{Struttura Logica di Una Pagina}
Una pagina ha una struttura logica che include \textbf{informazioni di servizio} e un'area contenente le stringhe che rappresentano i record. Il problema del riferimento ai record è risolto tramite l'identificatore \textbf{RID}: una coppia \texttt{(PID della pagina, Slot)}. L'organizzazione a slot permette la riallocazione interna del record senza modificarne il RID.

\paragraph{Tipi di Organizzazioni}
Le organizzazioni sono caratterizzate da occupazione di memoria e costo delle operazioni (ricerca, modifica, inserzione).

\begin{itemize}
    \item \textbf{Organizzazione Seriale (Heap file)}: I dati sono memorizzati in modo disordinato (nell'ordine di inserzione). È semplice e a basso costo di memoria, ma poco efficiente per grandi quantità di dati. È l'organizzazione standard di ogni DBMS.
\newpage
    \item \textbf{Organizzazione Sequenziale}: I dati sono ordinati sul valore di uno o più attributi. Questo facilita le operazioni SQL di ordinamento, raggruppamento e ricerca (\texttt{ORDER BY, GROUP BY, WHERE}) sugli attributi ordinati.
    Tuttavia, è più complessa da gestire in caso di aggiornamento/cancellazione/inserimento, richiedendo periodiche riorganizzazioni.
    In un file sequenziale ordinato, la ricerca binaria di un record richiede circa $\lceil \log_2 b \rceil + 1$ accessi a blocco/pagina, dove $b$ è il numero di blocchi.
    \item \textbf{Organizzazioni per Chiave}: L'obiettivo è trovare un record, nota la chiave, con il minor numero possibile di accessi a disco (idealmente 1 accesso) [19]. Le alternative sono il metodo \textbf{procedurale (hash)} o il metodo \textbf{tabellare (indice)}.
\end{itemize}


\paragraph{Hash File (Metodo Procedurale Statico)}
I record vengono allocati in una pagina il cui indirizzo è determinato dal valore della chiave tramite una funzione hash $H(\text{key}) \rightarrow \text{page address}$. Le collisioni (overflow) sono gestite di solito con liste collegate (\textit{linked lists}).
\begin{itemize}
    \item È l'organizzazione più efficiente per l'accesso diretto (puntuale) basato su valori della chiave.
    \item Non è efficiente per ricerche basate su intervalli di valori (\textit{range queries}).
    \item Funziona bene solo con file la cui dimensione non varia molto nel tempo (procedurale statico).
\end{itemize}

\subsubsection{Indici: Metodo Tabellare, B-tree e B+-tree}

\paragraph{Metodo Tabellare (Indice)}
Per le ricerche per chiave e per intervallo è preferibile il metodo tabellare, che utilizza un \textbf{indice}: un insieme ordinato di coppie $(k, r(k))$, dove $k$ è il valore della chiave e $r(k)$ è il riferimento al record.
L'indice è una struttura che contiene informazioni sulla posizione di memorizzazione delle tuple in base al valore del campo chiave. La realizzazione degli indici avviene tipicamente attraverso strutture ad albero multi-livello.

\paragraph{B-tree e B+-tree}
La struttura più usata e ottimizzata dai DBMS per la gestione degli indici è il \textbf{B+-albero}.

\subparagraph{Albero di Ricerca di Ordine P}
Un albero di ricerca di ordine $P$ è un albero i cui nodi contengono al più $P-1$ valori di ricerca (search value) e $P$ puntatori. Tali alberi possono essere memorizzati su disco, con ogni nodo assegnato a una pagina. Gli algoritmi di inserimento e cancellazione devono garantire il mantenimento dei vincoli, sebbene non garantiscano sempre che l'albero sia bilanciato (nodi foglia allo stesso livello).

\subparagraph{B-tree}
Un B-tree è una soluzione per mantenere l'albero bilanciato. Un nodo interno di un B-tree contiene tree pointer ($P_i$), chiavi di ricerca ($K_i$) e data pointer ($Pr_i$) che puntano al record o alla pagina che lo contiene. Tutti i nodi foglia sono posti allo stesso livello.

\subparagraph{B+-tree}
Un B+-tree è una variazione del B-tree in cui i \textbf{data pointer sono memorizzati solo nei nodi foglia}. I nodi foglia sono generalmente collegati tra loro (relazionati) per facilitare le \textit{range query}. I nodi interni hanno la funzione esclusiva di guidare la ricerca.
\begin{itemize}
    \item \textbf{Nodi Interni}: Hanno la forma $\langle P_1, K_1, P_2, K_2, \ldots, P_{q-1}, K_{q-1}, P_q \rangle$, dove $P_i$ sono solo \textit{tree pointer}.
    \item \textbf{Nodi Foglia}: Hanno la forma $\langle \langle K_1, Pr_1 \rangle, \ldots, \langle K_q, Pr_q \rangle, P_{\text{next}} \rangle$, dove $Pr_i$ sono i \textit{data pointer} e $P_{\text{next}}$ punta al nodo foglia successivo.
\end{itemize}

\paragraph{Tipologie di Indici}
\begin{itemize}
    \item \textbf{Indice Primario}: La \textbf{chiave di ordinamento} del file sequenziale \textbf{coincide} con la \textbf{chiave di ricerca} dell'indice. Esiste un record nell'indice per ogni blocco nel file di dati.
    \item \textbf{Indice Secondario}: La \textbf{chiave di ordinamento} e la \textbf{chiave di ricerca} \textbf{sono diverse}. Può essere definito su un campo non chiave (anche con valori duplicati). In questo caso quindi il \textbf{primo indice} è utilizzato per \textbf{mantenere l'ordine}, mentre il \textbf{secondo indice} è un \textbf{effettivo puntatore} al blocco o al record (RID).
\end{itemize}

\subsubsection{Tecniche di Ordinamento (Sort)}
L'ordinamento di archivi è fondamentale per rispondere a interrogazioni con \texttt{ORDER BY}, e per eseguire operazioni relazionali come \texttt{JOIN}, \texttt{SELECT DISTINCT}, e \texttt{GROUP BY}.

L'algoritmo più comune utilizzato dai DBMS è lo \textbf{Z-way Sort-Merge}. L'algoritmo opera in due fasi, supponendo di dover ordinare un file di $N_P$ pagine con a disposizione $N_B < N_P$ buffer in memoria centrale:
\begin{enumerate}
    \item \textbf{Sort Interno}: Le pagine vengono lette e i record di ogni pagina vengono ordinati (es. Quicksort), creando delle "run" che vengono scritte su disco in un file temporaneo. Avendo $N_B$ buffer, si possono ordinare $N_B$ pagine alla volta.
    \item \textbf{Merge} (\textbf{Fusione}): Le run vengono fuse in uno o più passi fino a ottenere un unico file ordinato.
\end{enumerate}

Miglioramenti sostanziali si ottengono fondendo $N_B - 1$ run alla volta (riservando 1 buffer per l'output). Il costo complessivo delle operazioni di I/O (leggere e riscrivere le pagine) è dato da:
$$
\text{Costo I/O} = 2 \times N_P \times \left( \lceil \log_{N_B-1} (N_P/N_B) \rceil + 1 \right)
$$
Un tempo di ordinamento può essere notevolmente ridotto aumentando il numero di buffer utilizzati per la fusione.

\newpage

\subsection{Realizzazione Operatori Relazionali}

La realizzazione efficiente di un DBMS richiede che gli operatori relazionali logici (come Proiezione, Selezione, Raggruppamento e Join) siano tradotti in \textbf{operatori fisici} realizzati tramite algoritmi specifici. Un operatore logico può essere implementato con diversi algoritmi, ciascuno codificato in un appropriato operatore fisico.

\subsubsection{Operatori Fisici e Interfaccia a Iteratore}

Gli algoritmi per implementare gli operatori relazionali sono codificati in specifici \textbf{operatori fisici}.
I DBMS definiscono questi operatori mediante un’interfaccia a \textbf{iteratore}. Un iteratore è un oggetto che fornisce i seguenti metodi principali:

\begin{itemize}
    \item \texttt{open}: Inizializza lo stato dell’operatore, alloca i buffer per l’input e l’output e richiama ricorsivamente \texttt{open} sugli operatori figli. Viene anche utilizzato per passare argomenti, come la condizione che un operatore \texttt{Filter} deve applicare.
    \item \texttt{next}: Richiede la successiva tupla del risultato dell’operatore. L'implementazione di questo metodo include l'invocazione di \texttt{next} sugli operatori figli e l'esecuzione di codice specifico dell'operatore, e in genere ritorna un record.
    \item \texttt{isDone}: Indica se ci sono ancora valori da leggere (generalmente booleano).
    \item \texttt{close}: Termina l’esecuzione dell’operatore, rilasciando le risorse allocate.
\end{itemize}

Esempi di operatori fisici includono \texttt{TableScan(R)} per la scansione completa di una relazione $R$, e \texttt{IndexScan(R, Idx)} per la scansione basata su un indice $Idx$.

\subsubsection{Realizzazione degli Operatori Fondamentali}

\paragraph{Proiezione (\(\Pi\))}
Se la proiezione include la clausola \texttt{DISTINCT} (eliminazione dei duplicati), un approccio comune è basato sull'ordinamento: si legge la relazione $R$, si scrive una relazione temporanea $T$ contenente solo gli attributi della \texttt{SELECT}, si ordina $T$ su tutti gli attributi, e infine si eliminano i duplicati.
Gli operatori fisici per la proiezione logica $\pi_b \{A_i\}$ (con duplicati) e $\pi \{A_i\}$ (senza duplicati) sono:
\begin{itemize}
    \item $Project(O, \{Ai\})$: Esegue la proiezione senza eliminazione dei duplicati.
    \item $Distinct(O)$: Elimina i duplicati dai record, assumendo che l'input $O$ sia ordinato.
\end{itemize}

\paragraph{Selezione/Restrizione (\(\sigma\))}
L'efficienza della selezione dipende dalla presenza o meno di indici.
\begin{itemize}
    \item \textbf{Senza indice e dati disordinati}: Il costo è $N_{pag}(R)$, ovvero il numero di pagine della relazione $R$. L'operatore fisico corrispondente è \texttt{Filter (O, $\psi$)}.
    \item \textbf{Con indice (es. B+-albero)}: Il costo si riduce a $CI + CD$, dove $CI$ è il costo di accesso all'indice e $CD$ è il costo di accesso ai dati. L'operatore fisico corrispondente è \texttt{IndexFilter (R, Idx, $\psi$)}, che esegue la restrizione utilizzando l'indice $Idx$.
\end{itemize}

\newpage

\paragraph{Raggruppamento e Aggregazione ($\Gamma$)}
Per le operazioni di aggregazione senza 

\texttt{GROUP BY} (es. \texttt{SELECT COUNT(*)}) si visitano i dati e si calcolano le funzioni di aggregazione.
Nel caso in cui sia presente la clausola \texttt{GROUP BY}, si utilizza tipicamente un approccio basato sull'ordinamento: i dati vengono ordinati sugli attributi del \texttt{GROUP BY}, poi visitati per calcolare le funzioni di aggregazione per ogni gruppo.
L'operatore fisico è $GroupBy(O, \{Ai\}, \{fi\})$, che raggruppa i record di $O$ sugli attributi $\{A_i\}$ e utilizza le funzioni di aggregazione $\{f_i\}$ (presenti nella \texttt{SELECT} e nella \texttt{HAVING}).
L'operatore restituisce record con gli attributi $\{A_i\}$ e le funzioni $\{f_i\}$, assumendo che i record di $O$ siano ordinati sugli $\{A_i\}$.

\subsubsection{Algoritmi di Giunzione (Join)}

L'esecuzione di una giunzione (Join) è cruciale; l'approccio di calcolare il Prodotto Cartesiano ($R \times S$) seguito da una restrizione è inefficiente a causa della potenziale dimensione di $R \times S$. Sebbene il Join sia logicamente commutativo, dal punto di vista fisico esiste una chiara distinzione tra l'operando sinistro (esterno o "outer") e l'operando destro (interno o "inner"), che influenza le prestazioni.

\paragraph{Nested Loops Join (Cicli Nidificati)}
L'algoritmo di base \texttt{Nested Loops} consiste nel visitare l'intera relazione interna $S$ per ogni record $r$ della relazione esterna $R$:
$$
\text{foreach record } r \text{ in } R \text{ do}
\begin{cases}
    \text{foreach record } s \text{ in } S \text{ do} \\
    \quad \text{if } r_i = s_j \text{ then aggiungi } \langle r, s \rangle \text{ al risultato}
\end{cases}
$$
Nel caso base (1 buffer per $R$ e 1 per $S$), il costo totale è:
$$
\text{Costo I/O} = N_{pag}(R) + N_{rec}(R) \times N_{pag}(S)
$$
Conviene scegliere come \textbf{relazione esterna} quella con un minor numero di tuple o, in generale, quella che soddisfa la condizione $N_{rec}(R) \times N_{pag}(S) < N_{rec}(S) \times N_{pag}(R)$, che corrisponde alla relazione con i record più grandi/lunghi.
L'ordine delle tuple nel risultato finale coincide con l'ordine eventualmente presente nella relazione esterna $R$.

\paragraph{Nested Loop A Pagine (\texttt{PageNestedLoop})}
Molti DBMS utilizzano la variante \texttt{Nested Loop a Pagine} (Page Nested Loop), che è più efficiente perché rinuncia a preservare l'ordine della relazione esterna ed esegue il join di tutte le tuple in memoria prima di richiedere nuove pagine della relazione interna $S$.
Logica: Per ogni pagina $p_R$ di $R$, si visitano tutte le pagine $p_S$ di $S$ ed si esegue il join di tutte le tuple in $p_R$ e $p_S$. La strategia si estende anche assegnando più buffer a $R$.

\newpage

\paragraph{Nested Loop con Indice (\texttt{IndexNestedLoop})}
Questa variante sostituisce la scansione completa della relazione interna $S$ con una scansione basata su un indice $I_{S_j}$ costruito sugli attributi di join di $S$. Questo accesso mediante indice riduce notevolmente i costi di esecuzione del Nested Loops Join.
$$
\text{foreach record } r \text{ in } R \text{ do}
\begin{cases}
    \text{foreach record } s \text{ in } \texttt{get-through-index}(I_{S_j}=r_i) \text{ do} \\
    \quad \text{aggiungi } \langle r, s \rangle \text{ al risultato}
\end{cases}
$$
L'operatore fisico è \texttt{IndexNestedLoop (OE, OI, $\psi_J$)}. L'operando interno $OI$ è spesso un \texttt{IndexFilter} sulla relazione interna.

\vspace*{15px}

\paragraph{Sort-Merge Join (\texttt{SortMerge})}
Questo algoritmo è applicabile quando entrambe le relazioni in input ($R$ e $S$) sono \textbf{ordinate sugli attributi di join}. L'ordinamento può essere raggiunto se la relazione è fisicamente ordinata o se esiste un indice sugli attributi di join.
L'algoritmo sfrutta l'ordinamento per evitare confronti inutili. Il numero di letture (senza contare il tempo di sort) è dell'ordine di $N_{pag}(R) + N_{pag}(S)$ se si accede sequenzialmente.
L'operatore fisico è \texttt{SortMerge (OE, OI, $\psi_J$)}.

\vspace*{25px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.625]{img/tipiImplementazioniJoin.png}
\end{figure}

\newpage

\subsection{Piani d'Accesso}

I piani d'accesso sono \textbf{espressioni algebriche} in cui gli \textbf{operatori logici} vengono \textbf{sostituiti} da \textbf{operatori fisici}.

\vspace*{10px}

In questa fase si applicano quindi le ottimizzazioni sulle interrogazioni, si sceglie quindi il piano di costo minimo tra quelli selezionabili.

\paragraph{Fasi del Processo di Ottimizzazione} Le fasi attraversate sono le seguenti:

\begin{itemize}
    \item \textbf{Analisi e Semplificazione}: Verifica la correttezza del comando, normalizzazione e semplificazione della condizione.
    \item \textbf{Trasformazione}: Trasformazione dell'albero con regole di equivalenza.
    \item \textbf{Ottimizzazione Fisica}: Definizione del piano di accesso, quindi scelta dell'algoritmo per eseguiro ogni operatore, l'ideale sarebbe trovare i migliori piani d'accesso ma l'obiettivo reale e quello di evitare i peggiori.
    \item \textbf{Esecuzione}: Viene eseguito il piano d'accesso.
\end{itemize}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.45]{img/esempioToPianoAccesso.png}
\end{figure}

\subsection{Gestione Transazioni}

Una transazione è un programma sequenziale costituito da operazioni che il sistema deve eseguire garantendo atomicità, serializzabilità e persistenza.

\vspace*{15px}

Il DBMS deve quindi \textbf{gestire} i \textbf{dati in memoria permanente}, il \textbf{buffer} a disposizione per il trasferimento da memoria centrale a memoria di massa e delle \textbf{ottimizzazioni} delle \textbf{interrogazioni}.

\newpage

\paragraph{Proprietà ACID} Elenchiamo le proprietà ACID delle transazioni:

\begin{itemize}
    \item \textbf{Atomicity}: Le transazioni devono essere eseguite con la regola del tutto o niente.
    \item \textbf{Consistency}: La transazione deve lasciare il DB in uno stato constente, non violando eventuali vincoli di integrità
    \item \textbf{Isolation}: L'esecuzione di una transazione deve essere indipendente dalle altre.
    \item \textbf{Durabilty}: L'effetto di una transazione conclusa con un \texttt{commit} non deve essere perso.
\end{itemize}

\paragraph{Transazione per il DBMS}

Anche se una transazione può eseguire molte operazioni, al DBMS interessano solo quelle di lettura/scrittura che definiremo così:

\begin{itemize}
    \item $r_i[x]$: Operazione che comporta la \textbf{lettura di una pagina nel buffer}, se non già presente.
    \item $w_i[x]$: Operazione che comporta un \textbf{eventuale lettura nel buffer} di una pagina e la sua \textbf{modifica nel buffer}, ma \textbf{non necessariamente} la sua \textbf{scrittura} in \textbf{memoria permanente}.
\end{itemize}

\paragraph{Tipi di Malfunzionamento}

Esistono tre tipi di malfunzionamento:

\begin{itemize}
    \item \textbf{Fallimenti di Transazioni}: Non comportano la perdita di dati in memoria temporanea ne persistente.
    \item \textbf{Fallimenti di Sistema}: Comportano perdite di dati in memoria temporanea ma non in memoria persistente.
    \item \textbf{Disastri}: Comportano perdite di dati in memoria permanente.
\end{itemize}

\subsection{Gestione Affidabilità}

Verifica che siano garantite le \textbf{proprietà} di \textbf{atomicità} e \textbf{persistenza} delle transazioni. Quindi questa fase è responsabile dei comandi \texttt{begin transaction}, \texttt{commit} e \texttt{rollback}.

\vspace*{10px}

\subsubsection{Ripresa a Caldo/Freddo}

Esistono due tipi di ripristino del sistema:

\begin{itemize}
    \item \textbf{Ripresa a Caldo}: Ripristino del sistema dopo un malfunzionamento software.
    \item \textbf{Ripresa a Freddo}: Ripristino del sistema dopo un malfunzionamento hardware.
\end{itemize}

\newpage

\subsubsection{File di LOG e Primitive Undo/Redo}

Tutte le operazioni svolte dal DBMS vengono riportate in un file di LOG:

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.4]{img/fileDiLog.png}
\end{figure}

Ogni transazione $T$ vengono indicate le operazioni di \texttt{begin}, \texttt{commit} e \texttt{abort} di $T$ con $B(T), C(T), A(T)$.

\vspace*{10px}

Indichiamo invece con $D(T, O, BS)$, $I(T, O, AS)$ e $U(T, O, BS, AS)$ rispettivamente le operazioni di \texttt{delete}, \texttt{insert} e \texttt{update}.

\paragraph{Primitive Undo/Redo} I record dei log associati ad una transazione consentono di \textbf{disfare (undo)} o \textbf{rifare (redo)} le corrispondenti azioni su una base di dati. Un log contiene \textbf{due tipi diversi} di \textbf{record}:

\begin{itemize}
    \item \textbf{Record di Transazione}: Tengono traccia di ogni tipo operazione relativa ad una transazione, quindi per ciascuna di esse si mantengono record di \texttt{begin}, \texttt{insert}, \texttt{delete}, \texttt{update}, \texttt{commit} e \texttt{abort}.
    \item \textbf{Record di Sistema}: Tengono traccia delle operazioni di sistema, quindi di elementi quali \texttt{dump} che permette la copia completa in backup della base di dati e \texttt{checkpoint} per contrassegnare periodicamente il file di LOG.
\end{itemize}

\paragraph{Regole di Scrittura dei LOG} Esistono diversi approcci:

\begin{itemize}
    \item \textbf{Regola Write Ahead Log (WAL)}: La parte \textbf{BS (Before State)} di ciascun record di log deve essere \textbf{scritta prima} che la corrispondente \textbf{operazione venga effettuata} nella base di dati.
    \item \textbf{Regola Commit Precedence}: La parte \textbf{AS (After State)} di ogni record di log deve essere scritta nel log \textbf{prima} di \textbf{effettuare il commit della transazione}.
\end{itemize}

\paragraph{Undo/Redo} Mostriamo quali politiche si seguono per disfare/rifare specifiche transazioni sulla base di dati:

\begin{itemize}
    \item \textbf{Undo}: Si segue la \textbf{politica della modifica libera}, ossia le modifiche possono essere portate nella base di dati stabile prima che la transizione termini. La \textbf{regola} per poter \textbf{disfare} invece è quelle del \textbf{Write Ahead Log}.
    \newpage
    \item \textbf{Redo}: Secondo il commit libero una transazione può essere considerata terminata normalmente prima che utte le modifiche bengano riportate nella base di dati stabile. La regola per poter rifare una transazione è quindi quella della commit rule, riportando le modifiche di una transizione nel log prima che questa raggiunga il commit.
\end{itemize}

\paragraph{Checkpoint} Si scrive sul LOG un mark che riporta l'elenco delle transazioni attive a tempo di checkpoint $BeginCheckpoint, \{ T_1, \cdots, T_n \}$. In parallelo alle normali operazioni delle transazioni, il gestore del buffer riporta sul disco tutte le pagine modificate. Successivamente si scrive sul giornale $EndCheckpoint$, in questo modo si certifica che tutte le scritture avvenute prima del $BeginCheckpoint$ siano state riportate su disco.

\vspace*{10px}

Attenzione, non abbiamo alcuna garanzia di aver riportato su disco le scritture avvenute tra $BeginCheckpoint$ ed $EndCheckpoint$.

\vspace*{10px}

\paragraph{Ripresa di Malfunzionamenti in base alla Tipologia} Applichiamo \textbf{undo/redo} in base al tipo di malfunzionamento.

\begin{itemize}
    \item \textbf{Fallimenti di Transazioni}: Si scrive nel LOG $(T, abort)$ e si applica il \texttt{redo}.
    \item \textbf{Fallimenti di Sistema}: La base di dati viene ripristinata con il comando restart, \textbf{partendo} quindi dallo \textbf{stato} dell'\textbf{ultimo checkpoint}.
    \begin{itemize}
        \item Le transazioni \textbf{non terminate} devono essere approcciate in \texttt{undo}.
        \item Le transazioni \textbf{terminate} devono essere approcciate in \texttt{redo}.
    \end{itemize}
    \item \textbf{Disastri}: Si riporta in linea la copia più recente della base di dati dal \textbf{dump di backup}, secondo il meccanismo della \textbf{ripartenza a freddo}.
\end{itemize}

\vspace*{10px}

\subsubsection{Procedure della Ripresa a Caldo}

Si seguono questi passi:

\begin{itemize}
    \item Trovare l'\textbf{ultimo checkpoint} percorrendo i \textbf{LOG a ritroso}.
    \item Costruire gli insiemi \texttt{undo} e \texttt{redo}.
    \item Ripercorrere \textbf{nuovamente a ritroso} i LOG, fino all'\textbf{azione più vecchia} nel insieme \texttt{undo} costruito prima.
    \item Percorrere il LOG \textbf{in avanti}, eseguendo tutte le azioni contenute nell'insieme \texttt{redo}.
\end{itemize}

\newpage

\subsection{Gestione della Concorrenza}

Il DBMS deve garantire sia \textbf{esecuzione concorrente} di transazioni sia \textbf{accesso concorrente} agli stessi \textbf{dati}.

\paragraph{Seriale e Serializzabile} Definiamo la differenza tra queste due proprietà:

\begin{itemize}
    \item \textbf{Seriale}: Un esecuzione di un insieme di transazioni $\{ T_1, \cdots, T_n \}$ si dice seriale se, per ogni coppia di transazioni $T_i, T_j$ tutte le operazioni di $T_i$ vengono eseguite prima di quelle di $T_j$.
    \begin{itemize}
        \item Uno schedule $S = \{ T_1, T_2, \cdots, T_n \}$ si dice \textbf{seriale} se appaiono consecutivamente, senza essere \textbf{inframezzate} da \textbf{azioni di altre transazioni}.
    \end{itemize}

    \item \textbf{Serializzabile}: Un insieme di transizioni si dice serializzabile se produce lo stesso effetto sulla base di dati di quello ottenibile eseguendo in serie, in qualche ordine, le sole transizioni normalmente.    
\end{itemize}

\subsubsection{Problematiche Gestione di Transazioni}

In un sistema reale le transazioni vengono eseguite in concorrenza, questo porta alla gestione di un insieme di problematiche note:

\vspace*{10px}

Mostriamo degli esempi, categorizzando queste casistiche di race condition:

\begin{itemize}
    \item \textbf{Perdita d'Aggiornamento}:
    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.4]{img/perditaAggiornamento.png}
    \end{figure}    
    \item \textbf{Lettura Sporca o Impropria}:
    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.4]{img/letturaSporca.png}
    \end{figure}
    \newpage
    \item \textbf{Letture Inconsistenti o Non Riproducibili}:
    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.4]{img/letturaInconsistente.png}
    \end{figure}
\end{itemize}

\paragraph{Controllo Concorrenza} I DBMS implementano \textbf{due classi} di \textbf{tecniche di controllo} di conocrrenza che grantiscono direttamente la \textbf{serializzabilità delle transazioni concorrenti}:

\begin{itemize}
    \item \textbf{Protocolli Pessimistici}: Tendono a ritardare l'esecuzione di transazioni che potrebbero generare conflitti, cercando di prevenire.
    \begin{itemize}
        \item Basato su fasi di lettura, validazione e scrittura.
    \end{itemize}
    \item \textbf{Protocolli Ottimistici}: Permettono l'esecuzione sovrapposta e non sincronizzata di transazioni ed effettuano controlli sui conflitti solo a fine commit.
    \begin{itemize}
        \item Metodi basati su lock e timestamps.
    \end{itemize}
\end{itemize}

\subsection{Gestione delle Transazioni}

\paragraph{Meccanismo dei Lock} Il meccanismo che blocca l'accesso ai dati ai quali una transazione accede ad altre transazioni:

\begin{itemize}
    \item Lock multi granularità.
    \item Lock in operazioni di scrittura/lettura.
\end{itemize}

Quando una risorsa è bloccata, le transazioni che ne richiedono l'accesso vengono messe in coda. Si definiscono due operazioni sui lock, ossia \textbf{lock/unlock}.

\paragraph{Serializzatore 2PL Stretto} Il serializzatore (\textbf{gestore della concorrenza}) ha il compito di \textbf{stabilire l'ordine} secondo il quale vanno eseguite le \textbf{singole operazioni} per rendere \textbf{serializzabile l'esecuzione} di un insieme di \textbf{transazioni}.

\paragraph{Strict Two Phase Locking} Protocollo che segue queste regole:

\begin{itemize}
    \item Ogni transazione, prima di effettuare un operazione, acquisisce il blocco corrispondente \textbf{chiedendo il lock}.
    \item Transazioni diverse non ottengono lock in conflitto.
    \item I lock si rilasciano alla terminazione della transazione, precisamente a tempo di commit.
\end{itemize}

La gestione a lock può però causare delle attese circolari infinite, dette \textbf{deadlocks}.

\newpage

\paragraph{Risoluzione di Deadlocks} Possiamo risolvere il problema dei deadlocks in diversi modi:

\begin{itemize}
    \item \textbf{Timeout}: Ogni operazione di una transazione ha un timeout, entro il quale deve essere completata, altrimenti va in abort.
    \item \textbf{Deadlock Avoidance}: Basata su \textbf{acquisizione di tutte le risorse necessarie} oppure \textbf{classi di priorità} tra transazioni.
    \item \textbf{Deadlock Detection}: Utilizzare algoritmi e/o grafi per identificare la presenza di cicli nella richiesta di risorse.    
\end{itemize}

\paragraph{Timestamp delle Transazioni} Metodo che associa un \textbf{timestamp} che rappresenta il momento di inizio della transazione, e si seguono due criteri:

\begin{itemize}
    \item Ogni transizione \textbf{non può leggere o scrivere} un \textbf{dato scritto} da una \textbf{transazione} con \textbf{timestamp maggiore}.
    \item Ogni transizione \textbf{non può scrivere} su un dato \textbf{già letto} da una \textbf{transazione} con \textbf{timestamp maggiore}.
\end{itemize}

\paragraph{Livelli di Isolamento e Consistenza} Esistono diversi livelli di garanzia di proprietà:

\begin{itemize}
    \item \textbf{Serializable}:
    \begin{itemize}
        \item La transazione leggerà solo cambiamenti fatti da transazioni concluse.
        \item Nessun valore letto o scritto da T verrà cambiato da altre transazioni fino alla sua conclusione.
        \item Se T legge un insieme di valori acceduti in ricerca, allora l'insieme non viene modificato da altre transazioni fino alla sua conclusione.
    \end{itemize}
    \item \textbf{Repeatable Read}:
    \begin{itemize}
        \item La transazione legge solo cambiamenti fatti da transazioni concluse.
        \item Nessun valore letto o scritto dalla transazione verrà camiato da altre transazioni fino alla sua conclusione.
    \end{itemize}
    \item \textbf{Read Committed}:
    \begin{itemize}
        \item La transazione legge solo cambiamenti fatti da transazioni concluse.
        \item La transazione non vede nessun cambiamento effettuato da transazioni concorrenti non concluse.
    \end{itemize}
    \item \textbf{Read Uncommitted}:
    \begin{itemize}
        \item La transazione è soggetta ad effetti fantasma, dato che può leggere modifiche fatte ad un oggetto da un altra transazione in esecuzione.
    \end{itemize}
\end{itemize}

\newpage

%\begin{figure}[htbp]
    %\center
    %\includegraphics[scale=0.4]{img/classiComplessita2.png}
%\end{figure}

\end{document}