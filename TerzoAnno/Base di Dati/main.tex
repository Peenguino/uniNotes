\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}

%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 
\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

\lstdefinelanguage{C}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}

\colorlet{LightGray}{White!90!Periwinkle}
\colorlet{LightOrange}{Orange!15}
\colorlet{LightGreen}{Green!15}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}

\NewEnviron{NORMAL}{% 
    \scalebox{2}{$\BODY$} 
} 

\declaretheoremstyle[name=Theorem,]{thmsty}
\declaretheorem[style=thmsty,numberwithin=section]{theorem}
\tcolorboxenvironment{theorem}{colback=LightGray}

\declaretheoremstyle[name=Proposition,]{prosty}
\declaretheorem[style=prosty,numberlike=theorem]{proposition}
\tcolorboxenvironment{proposition}{colback=LightOrange}

\declaretheoremstyle[name=Principle,]{prcpsty}
\declaretheorem[style=prcpsty,numberlike=theorem]{principle}
\tcolorboxenvironment{principle}{colback=LightGreen}

\setstretch{1.2}
\geometry{
    textheight=9in,
    textwidth=5.5in,
    top=1in,
    headheight=12pt,
    headsep=25pt,
    footskip=30pt
}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		\LARGE \textbf{\uppercase{Base di Dati}
		\HRule{2.0pt} \\ [0.6cm] \LARGE{Corso A} \vspace*{10\baselineskip}}
		}
        
\date{\text{Ultima Compilazione - }\today}
\author{\textbf{Autore} \\ 
		Giuseppe Acocella \\
		2025/26\\
        \url{https://github.com/Peenguino}}

\maketitle
\newpage

\tableofcontents

\newpage

\section{Introduzione}

I database sono insiemi di dati omogenei gestiti in collezioni. Alla base di questo definiamo tabelle, i cui campi possono fare riferimento ad altre tabelle
del database. Il topic di studio del corso è quello dei \textbf{database}, ma in questa introduzione definiamo un confronto con i \textbf{Data Warehouse}, per evidenziarne le \textbf{differenze}, anche
non essendo parte del programma del corso. 

\subsection{OLTP vs OLAP}

Mettiamo a confronto i due tipi di \textbf{ambiti applicativi}:

\begin{enumerate}
    \item \textbf{OLTP - Database (transazionale)}:
    \begin{enumerate}
        \item Utilizzo comune.
        \item Molti users.
        \item Dati analitici e relazionali.
        \item Relazioni statiche.
        \item Una query altera solitamente pochi record della tabella.
        \item Mirato all'utilizzo da parte delle applicazioni.
        \item Aggiornamenti frequenti.
        \item Visione dei dati correnti.
        \item Pensato per le transazioni.
    \end{enumerate}
    \item \textbf{OLAP - Data Warehouse (analitico)}:
    \begin{enumerate}
        \item Pochi utenti esperti.
        \item Dati multidimensionali.
        \item Relazioni dinamiche.
        \item Una query altera molti record della tabella.
        \item Mirato ai soggetti.
        \item Aggiornamenti rari ma massivi.
        \item Visione dei dati storica.
        \item Pensato per l'analisi di trend.
    \end{enumerate}
\end{enumerate}

Per questa motivazione, se dei dati presenti in un database, dovessero servire per un analisi di trend andrebbe effettuata un operazione abbastanza complessa di
estrazione e preparazione per l'immagazzinamento nel Data Warehouse. Entrambi (DB e DW) seguono una politica \textbf{schema first}, ossia viene prima definito uno schema
(insieme di campi) su cui verrà basata la successiva popolazione della collezione di informazioni.

\paragraph{Big Data} Un esempio di collezione di dati che \textbf{non segue} una politica \textbf{schema first}, basandosi infatti sulle proprietà di volume, varietà e velocità
non possono mantenere la rigidità impostata da uno schema. Solitamente sono quindi associati a sistemi NoSQL o approcci Data Lake.

\newpage

\subsection{Data Base Management Systems - DBMS}

Un DBMS (sistema per basi di dati) è un sistema centralizzato o distribuito che offre opportuni linguaggi per:

\begin{enumerate}
    \item Definire lo \textbf{schema} di una DB.
    \item Scegliere le \textbf{strutture dati} a \textbf{supporto} della DB.
    \item \textbf{Memorizzare} dati seguendo i vincoli definiti dai schemi del DB.
    \item Recuperare e modificare dati del DB tramite interrogazioni (\textbf{query}).
\end{enumerate}

Solitamente si pone tra i programmi applicativi e l'effettivo database per permettere l'interazione vincolata tra i due.

\paragraph{Dati gestiti dai DBMS}

Solitamente in un DB sono contenuti:

\begin{enumerate}
    \item \textbf{Metadati}: Descrivono permessi, applicazioni, parametri quantitativi sui dati effettivi. Seguono uno schema definito dal DBMS stesso.
    \item \textbf{Dati}: Rappresentazioni di fatti conformi alle definizioni degli schemi del DB.
    \begin{enumerate}
        \item Sono organizzati in \textbf{insiemi} strutturati ed \textbf{omogenei}, tra i quali sono definite delle \textbf{relazioni}.
        \item Sono accessibili tramite \textbf{transazioni}, operazioni atomiche che non hanno \textbf{mai effetti parziali}.
        \item Sono protetti da accessi non autorizzati e preservati da possibili malfunzionamenti.
        \item Sono utilizzabili in maniera concorrente da più utenti.
    \end{enumerate}
\end{enumerate}

\paragraph{DBMS a Modello Relazionale} Il modello relazionale è il più comune tra i DBMS commerciali e si basa sull'astrazione della \textbf{relazione}, ossia la \textbf{tabella}
vista come un insieme di record con campi ben definiti. Questo ci permette di poter creare tabelle ed interrogarle con un linguaggio ad alto livello.

\paragraph{Funzionalità dei DBMS} Elenchiamo quindi le proprietà garantite da un DBMS:

\begin{enumerate}
    \item Linguaggio per la definizione di un DB.
    \item Linguaggio per l'uso dei dati nel DB.
    \item Meccanismi di controllo del DB.
    \item Strumenti per la gestione admin del DB.
    \item Strumenti per lo sviluppo delle app che richiedono dati dal DB.
\end{enumerate}

\newpage

\subsubsection{Livelli di Vista Dati dei DBMS}

Per garantire le proprietà di \textbf{indipendenza fisica} e \textbf{logica} dei dati è stato proposto l'approccio di tre livelli di descrizione dei dati.

\begin{enumerate}
    \item \textbf{Indipendenza Fisica}: Le applicazioni che utilizzano il DB \textbf{non} devono essere modificati in seguito a modifiche dell'organizzazione fisica
    dei dati nel DB.
    \item \textbf{Indipendenza Logica}: Le applicazioni che utilizzano il DB \textbf{non} devono essere modificati in seguito a modifiche dello schema logico del DB.
\end{enumerate}

Gli effettivi livelli di vista sono invece:

\begin{enumerate}
    \item \textbf{Livello Fisico}: Gestione effettiva dell'immagazzinamento dei dati nel DB, ad esempio in questo livello si scelgono le strutture dati e gli algoritmi
    utilizzati dal DBMS per navigare tra i dati.
    \item \textbf{Livello Logico}: Descrizione della struttura degli insiemi di dati e delle relazioni tra di loro, astraendo completamente dalla loro gestione fisica.
    \item \textbf{Livello Vista Logica}: Sottoinsieme del livello logico esposto alle applicazioni esterne.
\end{enumerate}

\subsubsection{Meccanismi di Controllo Dati e Transazioni dei DBMS}

I DBMS cercano di garantire queste proprietà sui dati immagazzinati in un DB:

\begin{enumerate}
    \item \textbf{Integrità}: Mantenimento delle proprietà definite dallo schema.
    \item \textbf{Sicurezza}: Protezione dei dati da usi non autorizzati.
    \item \textbf{Affidabilità}: Protezione in caso di malfunzionamenti hardware/software.
\end{enumerate}

\paragraph{Transazioni - Operazioni Atomiche} Una transazione è una sequenza di azioni di lettura e scrittura in memoria permanente e di elaborazioni di dati in memoria
temporanea secondo queste proprietà:

\begin{enumerate}
    \item \textbf{Atomicità}: Le transazioni terminate prematuramente sono trattate come se non fossero mai iniziate. I loro effetti sul DB sono nulli.
    \item \textbf{Persistenza}: Le transazioni terminate con successo sono permanenti, ossia non alterabili neanche da malfunzionamenti.
    \item \textbf{Serializzabilità}: L'esecuzione concorrente di più transazioni è vista come un esecuzione seriale di transazioni.
\end{enumerate}

\paragraph{Riepilogo Pro e Contro Utilizzo DBMS}

Elenchiamo rapidamente i pro e i contro di questo approccio:

\begin{enumerate}
    \item \textbf{Pro}: Indipendenza dei dati, recupero efficiente dei dati, integrità e sicurezza, accessi interattivi e concorrenti, amministrazione e riduzione dei tempi di
    sviluppo delle applicazioni.
    \item \textbf{Contro}: Necessaria la definizione di uno schema, gestiscono solo dati strutturati ed omogenei, ottimizzati per app OLTP e non per OLAP.
\end{enumerate}

\newpage

\section{Progettazione di una Base Dati}

La nascita dei database è causata da alcune problematiche presenti in sistemi di
gestione informazioni più datati. Un classico esempio di problematica è quella della
\textbf{ridondanza logica}, ossia un informazione ripetuta più volte tra vari record. In queste
casistiche si preferisce astrarre e fare riferimento solo una volta ad un dato.

\subsection{Attori e Fasi della Progettazione di DB}

Elenchiamo attori e fasi della progettazione di una base dati.

\paragraph{Attori della Progettazione} Elenchiamoli:

\begin{enumerate}
    \item \textbf{Committente}: Azienda che commissiona la creazione di una base dati, per una propria necessità.
    \item \textbf{Consulente}: Progettisti del DB.
    \item \textbf{Utente}: Chi usufruirà del DB, solitamente un dipendente del committente.
    \item \textbf{DB Administrator}: Amministratore del DB.
\end{enumerate}

\paragraph{Fasi della Progettazione} Si definiscono fasi specifiche della progettazione di un DB:

\begin{enumerate}
    \item \textbf{Specifica Requisiti Committente}: Il committente deve definire le proprie necessità ed il consulente deve
    raccogliere le informazioni.
    \item \textbf{Progettazione Concettuale}: Realizzazione di uno schema concettuale orientato agli oggetti che deve essere osservabile ed
    approvato dal committente. In questa fase si astrae completamente da dettagli tecnici d'implementazione/ottimizzazione
    proprio perchè deve risultare semplice al committente e non deve causare ridondanza logica.
    \item \textbf{Progettazione Logica}: Concretizzazione della progettazione concettuale tramite linguaggi relazionali.
    \item \textbf{Progettazione Fisica}: Allocazione fisica delle tabelle generate dal linguaggio relazionale della progettazione logica.
\end{enumerate}

\paragraph{Progettazione come Modellazione} Spesso il committente stesso non riesce a rendere esplicite tutte le sue necessità, di conseguenza
è compito del consulente capire a fondo i comportamenti ed i dettagli necessari alla modellazione logica.

\subsection{Progettazione Concettuale}

Questo linguaggio si basa su $3$ operatori diversi:

\begin{enumerate}
    \item \textbf{Classi (aka Collezioni)}: Ad esempio la classe Persone di entità persona. Formalmente una classe modella un insieme di entità omogenee. Queste possono essere
    entità fisiche, avvenimenti o \textbf{modelli (progetti)} di entità.
    \newpage
    \item \textbf{Associazioni}: Insieme di fatti binari, ad esempio associazione di un proprietario ad un auto.
    \item \textbf{Sottoclassi}: Sottoinsieme di una classe, come Studenti può esserlo di Persone.
\end{enumerate}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.6]{img/esempioRelazione1.png}
\end{figure}

\subsubsection{Associazioni e Cardinalità}

Formalmente le associazioni sono insiemi di coppie, quindi delle relazioni. Il tipo di freccetta che indica l'associazione
è detta cardinalità e corrisponde informalmente alla domanda:

\[ \text{"Per ogni elemento della classe A quanti della classe B?"} \]

Chiaramente va fatto sulla stessa direzione per entrambi i versi. Questo permette di risolvere le ambiguità causate dalla terminologia comune che è detta:

\[ \text{"Uno a Molti"} \:\: \text{oppure} \:\: \text{"Molti a Molti"} \]

che in qualche modo genera ambiguità perchè è come se si tenesse in conto solo di un verso. E' fondamentale ricordarsi quindi che la caratterizzazione della cardinalità di un associazione va
fatta in entrambi i versi.

Graficamente quindi avremo queste possibilità alle estremità delle associazioni:

\begin{enumerate}
    \item \textbf{Freccia Singola}: Per ogni elemento della classe di partenza è presente un elemento nella classe d'arrivo.
    \item \textbf{Freccia Doppia}: Per ogni elemento della classe di partenza sono presenti più elementi nella classe d'arrivo.
    \item \textbf{Trattino}: Nessun limite inferiore, di conseguenza per ogni elemento della classe di partenza può anche non essere presente alcun elemento nella classe d'arrivo.
\end{enumerate}

Esistono diverse notazioni grafiche, ma queste dispense fanno riferimento a quelle utilizzate durante gli esercizi del corso, quindi questa sarà la notazione comune di riferimento.

\newpage

\subsubsection{Associazioni Ternarie/con Attributi e Reificazione}

A volte le associazioni potrebbero complicarsi perchè:

\begin{enumerate}
    \item Potrebbero avere la \textbf{necessità} di avere degli \textbf{attributi}. Ad esempio in un caso di associazione tra Clienti e Stanze, la tariffa potrebbe non essere
    nè attributo di Clienti e nè di Stanze. In questo caso si assegna un \textbf{attributo} all'\textbf{associazione}.

    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.55]{img/associazioneAttributo.png}
    \end{figure}

    \item Potrei invece immaginare l'attributo come \textbf{vera} e \textbf{propria entità} di una specifica classe Tariffe. In quel caso non starei semplicemente dando 
    un attributo 

    
    all'associazione ma starei componendo un \textbf{associazione ternaria}.
    \begin{figure}[htbp]
        \center
        \includegraphics[scale=0.55]{img/associazioneTernaria.png}
    \end{figure}

\end{enumerate}

\paragraph{Reificazione} Si preferisce, nei casi illustrati sopra, semplificare la gestione 

dell'associazione tramite processo di reificazione, ossia la creazione di una classe di supporto aggiuntiva che permetta la gestione
regolare delle associazioni viste prima. Si illustrano le reificazioni delle associazioni viste sopra:

\vspace*{15px}

\begin{figure}[htbp]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{img/esempioReificazione1.png}
        \caption{Reificazione di Associazione con Attributo}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{img/esempioReificazione2.png}
        \caption{Reificazione di Associazione Ternaria}
    \end{minipage}
\end{figure}

Un dettaglio da notare è la \textbf{cardinalità} sulla nuova classe di supporto, infatti in \textbf{direzione} della \textbf{nuova classe} sarà presente un associazione di \textbf{uno a molti}.

\newpage

\subsubsection{Sottoclassi e Tipologie}

Una \textbf{sottoclasse} è un sottoinsieme di elementi di una classe, per i quali prevediamo di raccogliere ulteriori informazioni.

\[ \text{Studenti} \subseteq \text{Persone} \]
\[ \text{Libri Rari} \subseteq \text{Libri} \]

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.7]{img/notazioneGraficaSottoclassi.png}
    \caption{Notazione grafica di riferimento}
\end{figure}

\vspace*{10px}

Esistono varie tipologie di sottoclassi:

\vspace*{10px}

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.7]{img/tipiDiSottoclassi.png}
\end{figure}

\newpage

\subsection{Progettazione Logica}

Il \textbf{tipo} di \textbf{schema logico} presentato in questo corso è lo \textbf{schema relazionale}.

\vspace*{10px}

Basata su \textbf{schemi relazionali} detti informalmente \textbf{tabelle} di valori elementari con chiavi primarie:

\vspace*{5px}

\begin{center}
\begin{tabular}{ |c|c|c|c| }
    \hline
    \multicolumn{4}{|c|}{Impiegati} \\
    \hline
    \underline{IdImpiegato} & Nome & Stipendio & IdReparto* \\
    \hline
    232 & Lucia & 1200 & Y1 \\
    \hline
    143 & Luigi & 1500 & X2 \\
    \hline
\end{tabular}
\end{center}

\vspace*{5px}

In questo contesto \textbf{non esiste differenza} tra \textbf{attributi} ed \textbf{associazioni} dato che le chiavi
esterne permetteranno il \textbf{riferimento} ad \textbf{altre tabelle}.

\vspace*{5px}

\begin{center}
\begin{tabular}{ |c|c| }
    \hline
    \multicolumn{2}{|c|}{Reparti} \\
    \hline
    \underline{IdReparto} & Budget \\
    \hline
    Y1 & 100000 \\
    \hline
    X2 & 200000 \\
    \hline
\end{tabular}
\end{center}

\vspace*{5px}

Solitamente quindi si definisce \textbf{uno dei campi} della \textbf{tabella} come \textbf{chiave primaria}, ossia che \textbf{identifica} univocamente \textbf{la riga}. Invece il campo che permette la dereferenziazione univoca
di una riga in un altra tabella è detta \textbf{chiave esterna}, che corrisponde alla \textbf{chiave primaria} della \textbf{tabella esterna}.

\paragraph{Chiave e Superchiave Minimale} Definiamo \textbf{superchiave} qualsiasi \textbf{insieme di attributi} che \textbf{non} può \textbf{ripetersi} in \textbf{righe diverse}. Si definisce \textbf{chiave} una \textbf{superchiave minimale}, ossia un insieme di attributi a cui
non possiamo rimuovere alcun attributo. Sarà quindi scelta del progettista scegliere una \textbf{chiave primaria tra} tutte le \textbf{chiavi possibili}.

\subsubsection{Da Schema Concettuale a Schema Logico - Fasi}

Elenchiamo e descriviamo le fasi necessarie per il passaggio da schema \textbf{concettuale} a \textbf{logico}.

\begin{enumerate}
    \item Aggiungere una \textbf{chiave primaria} artificiale ad ogni collezione che ne ha bisogno.
    \begin{enumerate}
        \item Una chiave deve essere \textbf{immutabile}, \textbf{muta}, ossia non deve portare con se alcuna informazione, ed \textbf{invisibile} agli utenti.
    \end{enumerate}
    \item Tradurre le \textbf{associazioni} e le \textbf{inclusioni} in \textbf{chiavi esterne}.
    \begin{enumerate}
        \item Una associazione $1-N$ diventano \textbf{chiavi esterne}.
        \item Una associazione $M-N$ diventano \textbf{tabelle} con due chiavi esterne che puntano alle tabelle tra cui esiste l'associazione.
    \end{enumerate}
    \item Tradurre gli \textbf{attributi multivalore} in \textbf{tabelle}.
    \item \textbf{Appiattire} gli \textbf{attributi complessi}, ossia da struct a lista di parametri semplici.
\end{enumerate}

% Ti manca la parte su ATTRIBUTI MULTIVALORE e PARTIZIONE DI TABELLE, attendi le slide

\newpage

Nello schema logico le \textbf{sottoclassi} vengono rappresentate come \textbf{nuove tabelle}, con chiavi esterne in direzione
della superclasse.

\vspace*{10px}

\begin{center}
\begin{tabular}{ |c|c| }
    \hline
    \multicolumn{2}{|c|}{Persone} \\
    \hline
    \underline{PId} & Nome \\
    \hline
\end{tabular}
\end{center}

\makebox[0.95\textwidth][c]{
\begin{tabular}{ |c|c|c| }
    \hline
    \multicolumn{3}{|c|}{Impiegati} \\
    \hline
    Reparto & Stipendio & \underline{PId}* \\
    \hline
\end{tabular}
\hspace{0.2cm}
\begin{tabular}{ |c|c|c| }
    \hline
    \multicolumn{3}{|c|}{Consulenti} \\
    \hline
    Progetto & Tariffa & \underline{PId}* \\
    \hline
\end{tabular}
}

\vspace*{10px}

\section{Algebra Relazionale}

Insieme di operatori su relazioni che restituiscono altre relazioni. La forza di questo sistema di operazioni è che sono componibili, e formano successivamente ulteriori operazioni.

\subsection{Operatori Primitivi} Elenchiamo gli operatori primitivi:

\begin{enumerate}
    \item \textbf{Proiezione}: Data una tabella $R$, la funzione $\Pi_{A,B}(R)$ genera una nuova tabella in cui si mostrano solo le colonne $A,B$ della tabella $R$.
    \item \textbf{Restrizione}: Data una tabella $R$, la funzione $\rho_{cond}(R)$ genera una nuova tabella in cui si mostrano solo le righe in cui vale la condizione $cond$.
    \item \textbf{Unione}: Unione $R \: \cup \: S$, l'operazione può essere effettuata solo tra tabelle con lo stesso schema.
    \item \textbf{Differenza}: Differenza $R - S$, l'operazione può essere effettuata solo tra tabelle con lo stesso schema.
    \item \textbf{Prodotto Cartesiano}: Date due tabelle $R$ ed $S$, produce una nuova tabella con tutte le possibili n-uple formate dal prodotto delle due tabelle.
    \item \textbf{Ridenominazione}: Ridenominazione $\delta_{A \rightarrow B}(R)$, consiste informalmente nella ridenominazione dei campi che definiscono le colonne dello schema. Questo perchè altre operazioni binarie richiedono che le colonne di schemi diversi non abbiano gli stessi nomi.
\end{enumerate}

\subsection{Operatori Derivati} Elenchiamo gli operatori derivati:

\begin{enumerate}
    \item \textbf{Intersezione}: Date due tabelle $R$ ed $S$, restituisce le righe (tuple) che sono sia in $R$ sia in $S$, dunque è necessario che le due tabelle abbiano lo \textbf{stesso schema}.
    \[ R \: \cap \: S = R - (R - S) \]
    \item \textbf{Giunzione (Join)}: L'operazione $R \bowtie_{R.A = S.B} S$ combina le righe (tuple) di $R$ ed $S$ \textbf{solo quando} un attibuto A di R \textbf{è uguale} ad un attributo B di S. Questa operazione è derivata da:
    \[ R \bowtie_{R.A = S.B} S = \rho_{R.A = S.B} (R \times S) \]
    \newpage
    \item \textbf{Giunzione Naturale}: L'operazione $R \:v\: S$ è una giunzione automatica su tutti gli attributi che hanno lo stesso nome in entrambe le relazioni, quindi non sono specificate condizioni.
\end{enumerate}

\paragraph{Raggruppamento - Group By} Data una tabella $A$ si definisce uno dei suoi attributi $(A_{i})$ come \textbf{dimensione} e si genera una nuova tabella definendo funzioni $(f_{i})$ sulle altre colonne dette \textbf{misure}. Formalmente la definiamo quindi come $\Gamma_{\{A_i\}\{f_i\}}(R)$.

\begin{figure}[htbp]
    \center
    \includegraphics[scale=0.55]{img/groupBy.png}
\end{figure}

\newpage

\section{Linguaggio SQL}

Linguaggio di interrogazione su calcolo di multiset basato su delle clausole specifiche:

\subsection{Clausole SQL}

\begin{enumerate}
    \item \textbf{SELECT}: Permette di selezionare specifici \textbf{campi della tabella} generata nella clausola FROM.
    \item \textbf{FROM}: Permette la combinazione di tabelle. In questa clausola abbiamo modo di utilizzare anche la clausola JOIN per unire più tabelle tramite specifici campi.
    Il modo più comune per l'utilizzo della JOIN è:
    \[ FROM \:\: Studenti \:\: s \:\: JOIN \:\: Esami \:\: e \:\: ON \:\: s.SId = e.SId \]
    \item \textbf{WHERE}: Permette di definire una restrizione sulle righe che soddisfano la condizione passata alla WHERE.
    Accade spesso di impostare una condizione per la WHERE con una sottoquery come parte dell'espressione di controllo. Esistono diversi tipi di sottoquery:
    \begin{enumerate}
        \item \textbf{Sottoquery restituisce un singolo valore}: La sottoquery calcola un valore (AVG, MAX, MIN...) e la WHERE utilizza questo valore nel confronto.
        \item \textbf{Sottoquery restituisce una colonna}: Vengono utilizzati operatori specifici come $IN, \: ANY, \: ALL$ con operando a destra il campo della colonna esterna e come operando a sinistra
        il risultato della sottoquery.
        \begin{lstlisting}
    SELECT name
    FROM employees
    WHERE dept_id IN (
        SELECT id
        FROM departments
        WHERE location = 'Rome'
        );
        \end{lstlisting}
        \item \textbf{Sottoquery correlata}: Sottoquery che viene valutata per ogni riga della tabella in questione, in modo tale che si possa confrontare un valore a tutti quelli di un campo della tabella.
        \begin{lstlisting}
    SELECT e.name, e.salary
    FROM employees AS e
    WHERE e.salary > (
        SELECT AVG(salary)
        FROM employees
        WHERE dept_id = e.dept_id
        );
        \end{lstlisting}
    \end{enumerate}
    \item \textbf{ORDER BY}: Permette l'ordinamento su un campo della tabella.
    \newpage
    \item \textbf{GROUP BY}: Si definisce come nell'algebra relazionale con delle \textit{dimensioni} e \textit{misure}. Le \textit{dimensioni} vanno riportate come argomenti della clausola \textbf{GROUP BY}, mentre le misure come \textit{argomenti} della \textbf{SELECT}.    
    \begin{lstlisting}
    SELECT s.Nome, AVG(e.Voto)
    FROM Studenti s, Esami e
    WHERE s.SId = e. SId
    GROUP BY s. SId
    \end{lstlisting}
    \vspace*{-15px}
    Quindi si genera per ogni gruppo una linea.
    \item \textbf{HAVING}: Questa clausola può essere applicata solo su dimensioni esplicite della GROUP BY e operazioni su attributi non dimensionali. Quindi la HAVING permette
    la cancellazione dei gruppi che violano la clausola HAVING.
    Quindi riassumendo tutte le clausole presentate in una pseudoquery:
    \begin{lstlisting}
    SELECT ... 
    FROM ...
    WHERE ... 
    GROUP BY ...
    HAVING ... 
    \end{lstlisting}
    \vspace*{-15px}
    Questa query eseguirà questi passi:
    \begin{enumerate}
        \item Esegue le clausole FROM e WHERE, calcolando quindi una tabella di partenza.
        \item Partiziona la tabella eseguendo il GROUP BY in base alle dimensioni fornite a questa clausola. Ogni gruppo diventa quindi una linea.
        \item Elimina i gruppi che violano le clausole passate alla HAVING.
        \item Proietta le colonne specificate nella clausola SELECT.
    \end{enumerate}
\end{enumerate}

\subsection{Valore NULL}

In SQL è ammesso il valore \textit{NULL} che definisce la non conoscenza di un valore di un campo. Questo però causa problemi in vari contesti, dato che andrà regolato il suo comportamento.
Il valore \textit{NULL} va letto come "non conosco il valore", quindi non si confronteranno i campi con un $= NULL$ ma esistono predicati appositi per verificare la presenza del \textit{NULL}, ad esempio $IS \: NULL$.

\vspace*{10px}

\subsection{Quantificazione Esistenziale/Universale in SQL}

\vspace*{10px}

\begin{enumerate}
    \item \textbf{Quantificazione Esistenziale}: In SQL è presente l'operatore EXISTS che ci permette di descrivere una condizione esistenziale scorrendo una tabella.
    \newpage
    In linguaggio logico avremmo così definito la quantificazione esistenziale:
    \[ \{ s.Nome \: | \: s \in Studenti \: \land \: \exists e \in Esami \: (e.SId = s.SId \land e.Voto = 27)  \} \]
    Come viene tradotta in SQL? Presentiamo un esempio utilizzando l'operatore EXISTS.
    \begin{lstlisting}
    SELECT s.Nome
    FROM Studenti s
    WHERE EXISTS 
        (SELECT *
        FROM Esami e
        WHERE e.SId = s.SId AND e.Voto > 27)
    \end{lstlisting}
    \item \textbf{Quantificazione Universale}: In SQL non esiste un operatore di quantificazione universale esplicito, quindi il modo più comune è quello di utilizzare un \textbf{NOT EXISTS} in combinazione con la \textbf{condizione negata alla query interna}. Presentiamo
    anche in questo caso un esempio di quantificazione universale in linguaggio matematico e successivamente in SQL.
    \vspace*{-5px}
    \[ \{ s.Nome \: | \: s \in Studenti \land \forall e \in Esami (e.SId = s.SId \land e.Voto = 27) \} \]
    In SQL questa viene tradotta in
    \begin{lstlisting}
    SELECT s.Nome
    FROM Studenti s
    WHERE NOT EXISTS
        (SELECT *
        FROM Esami e
        WHERE e.SId = s.SId AND e.Voto <> 30)
    \end{lstlisting}
    \vspace*{-20px}
    \paragraph{NULL e Quantificazione Universale} La quantificazione universale torna esito positivo sugli insiemi vuoti. Bisogna tener conto di questa caratteristica se non vogliamo nel risultato anche righe che erano nulle laddove si testava la condizione.
\end{enumerate}

\subsection{Outer Join}

Citiamo prima il comportamento di una \textbf{Inner Natural Join}:

\[
\begin{array}{c}
\text{R}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & B \\
\hline
1 & a \\
2 & b \\
3 & c \\
\hline
\end{array}
\end{array}
\quad
\text{NATURAL JOIN}
\quad
\begin{array}{c}
\text{S}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & C \\
\hline
1 & x \\
3 & y \\
5 & z \\
\hline
\end{array}
\end{array}
\quad
\Longrightarrow
\quad
\begin{array}{c}
\text{R} \bowtie \text{S}
\\[2mm]
\begin{array}{|c|c|c|}
\hline
A & B & C \\
\hline
1 & a & x \\
3 & c & y \\
\hline
\end{array}
\end{array}
\]

Si legano quindi solo in base alle chiavi esterne coincidenti.

\newpage

Diverso è invece il comportamento della Outer Join:

\begin{enumerate}
    \item \textbf{Left Outer Join}: Effettua una Natural Join e a questa aggiunge le righe della tabella a sinistra, aggiungendo nei \textit{NULL} dove necessario:
    \[
\begin{array}{c}
\text{R}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & B \\
\hline
1 & a \\
2 & b \\
3 & c \\
\hline
\end{array}
\end{array}
\quad
\text{LEFT JOIN}
\quad
\begin{array}{c}
\text{S}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & C \\
\hline
1 & x \\
3 & y \\
5 & z \\
\hline
\end{array}
\end{array}
\quad
\Longrightarrow
\quad
\begin{array}{c}
\text{R} \bowtie \text{S}
\\[2mm]
\begin{array}{|c|c|c|}
\hline
A & B & C \\
\hline
1 & a & x \\
3 & c & y \\
5 &   & z \\
\hline
\end{array}
\end{array}
\]

\vspace*{15px}

\item \textbf{Full Join}: Effettua una Natural Join e a questa aggiunge le righe di entrambe le tabelle, aggiungendo nei \textit{NULL} dove necessario:

    \[
\begin{array}{c}
\text{R}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & B \\
\hline
1 & a \\
2 & b \\
3 & c \\
\hline
\end{array}
\end{array}
\quad
\text{FULL JOIN}
\quad
\begin{array}{c}
\text{S}
\\[2mm]
\begin{array}{|c|c|}
\hline
A & C \\
\hline
1 & x \\
3 & y \\
5 & z \\
\hline
\end{array}
\end{array}
\quad
\Longrightarrow
\quad
\begin{array}{c}
\text{R} \bowtie \text{S}
\\[2mm]
\begin{array}{|c|c|c|}
\hline
A & B & C \\
\hline
1 & a & x \\
2 & b &  \\
3 & c & y \\
5 &   & z \\

\hline
\end{array}
\end{array}
\]

\end{enumerate}

Questi tipi di Join ci permettono di manipolare risultati nulli, ad esempio:

\vspace*{15px}

\begin{enumerate}
    \item \textbf{Contare Esami di Ogni Studente, no Left Join}: Escludo chi non ha sostenuto alcun esame:
\begin{lstlisting}
    SELECT s.Nome, COUNT(*)
    FROM Studenti s JOIN Esami e USING (SId)
\end{lstlisting}
\vspace*{-15px}
    \item \textbf{Contare Esami di Ogni Studente, con Left Join}: Includo chi non ha sostenuto alcun esame:
\begin{lstlisting}
    SELECT s.Nome, COUNT(e.Voto)
    FROM Studenti s LEFT JOIN Esami e USING (SId)
    GROUP BY s.SId, s.Nome
\end{lstlisting}
\vspace*{-15px}
\end{enumerate}

\newpage

\subsection{Programmazione e SQL}

Si mostrano dei concetti più teorici riguardanti il SQL.

\subsubsection{Approcci Integrazione SQL}

Esistono vari approcci che permettono l'integrazione dell'SQL ai linguaggi di programmazione:

\begin{enumerate}
    \item \textbf{Linguaggio Integrato}: PL/SQL definito ad esempio da Oracle è SQL esteso fino a diventare un linguaggio completo, quindi viene compilato contemporaneamente sia l'SQL sia la parte di programmazione standard.
    \begin{itemize}
        \item \textbf{Vantaggio}: Viene compilato ed eseguito direttamente dal DBMS, permettendo operazioni come controlli per ruoli d'accesso in compilazione.
        \item Oracle PL/SQL permette la lettura di tipi del database e il loro utilizzo per la dichiarazione di variabili. In questo caso il codice SQL viene utilizzato come \textit{template}, interpretato secondo SQL e sostituito sintatticamente, per poi eseguire il linguaggio esterno.
    \end{itemize}

    \item \textbf{Linguaggio Convenzionale + API}: Si utilizza una libreria più un'interfaccia per l'interazione tra il linguaggio convenzionale e il DBMS.
    \begin{itemize}
        \item In questo contesto, il linguaggio convenzionale non effettua controlli statici 
        
        sull'SQL, poiché esso viene considerato come una \textbf{normale stringa}.
        \item \textbf{Vantaggio}: Le query vengono inviate al DBMS come stringhe.
        \item Tuttavia, non si risolve il disallineamento semantico (mismatch) dovuto a elementi come \texttt{NULL} o \texttt{MAX\_INT}.
    \end{itemize}

    \item \textbf{SQL Ospitato}: Approccio che utilizza costrutti come \texttt{begin SQL} ed \texttt{end SQL}, permettendo la condivisione di variabili tra, ad esempio, Python e SQL.
    \begin{itemize}
        \item Il precompilatore si occupa di compilare e di chiamare l'API, quindi i controlli a tempo di compilazione sono effettuati anche per l'SQL (differenza rilevante rispetto al caso precedente).
        \item Possono emergere problemi dovuti alla traduzione SQL, talvolta difficili da individuare.
        \item Possono sorgere inoltre problemi di differenza di espressività tra SQL (insiemi, record) e il linguaggio ospite.
    \end{itemize}
\end{enumerate}

\paragraph{Cursore/Buffer} Meccanismo che permette di scannerizzare elementi, è associato ad una espressione SQL e permette lo scorrimento di dati riga per riga con operazioni di \texttt{FETCH}.

\newpage

\subsubsection{Creazione Tabelle}

La definizione di una tabella in SQL è importante da saper leggere, anche se raramente viene richiesto di crearne una esplicitamente.

\vspace*{10px}

\begin{lstlisting}
    CREATE TABLE Employees( 
        Code CHAR(8) NOT NULL,
        Name CHAR(20),
        Birthyear INTEGER CHECK (Birthyear < 2005),
        Qualification CHAR(20) DEFAULT 'Employee',
        Supervisor CHAR(8),
        PRIMARY KEY pk_Employees (Code),
        FOREIGN KEY fk_Employees (Supervisor)
            REFERENCES Employees
    );

    CREATE TABLE Dependents(
        Name CHAR(20),
        Birthyear INTEGER,
        EmployeeCode CHAR(8),
        FOREIGN KEY fk_Dependents (EmployeeCode)
            REFERENCES Employees
    );
\end{lstlisting}

\vspace*{-10px}

\begin{itemize}
    \item Nella \textbf{foreign key} va specificato quale attributo punta a quale tabella.
    \item I comandi \texttt{DROP} e \texttt{ALTER} permettono rispettivamente di cancellare e modificare una tabella.
    \item \textbf{Vincolo di Foreign Key}: se un valore referenziato viene eliminato, è possibile definire comportamenti diversi, come:
    \begin{itemize}
        \item Impostare il valore a \texttt{NULL}.
        \item Usare \texttt{ON DELETE CASCADE}, che propaga la cancellazione.
    \end{itemize}
\end{itemize}

\subsubsection{Viste e Viste Materializzate}

\paragraph{Viste Materializzate}

Una vista materializzata è una \textbf{tabella fisica} costruita come risultato dell'esecuzione di una query su altre tabelle. 

\vspace*{10px}

\begin{lstlisting}
    CREATE TABLE Name SelectExpression;

    CREATE TABLE Supervisors AS
    SELECT Code, Name, Qualification, Salary
    FROM Employees
    WHERE Supervisor IS NULL;
\end{lstlisting}

\vspace*{-10px}

Questo approccio è utile quando i dati cambiano raramente, poiché le modifiche nella tabella originale non si riflettono automaticamente nella vista materializzata.

\newpage

\paragraph{Viste}

Le viste standard sono \textbf{viste virtuali}, cioè query memorizzate che non vengono eseguite finché non vengono richieste.

\vspace*{10px}

\begin{lstlisting}
    CREATE VIEW Name [(Attribute {, Attribute})]
    AS SelectExpression [WITH CHECK OPTION];

    CREATE VIEW Supervisors AS
    SELECT Code, Name, Qualification, Salary
    FROM Employees
    WHERE Supervisor IS NULL;
\end{lstlisting}

\vspace*{-10px}

Generalmente, le viste non vengono aggiornate direttamente perché non contengono dati reali.

\subsection{Motivazioni per l'uso delle viste}

\begin{itemize}
    \item Permettono di nascondere dati, garantendo \textbf{indipendenza logica}.
    \item Consentono \textbf{diverse rappresentazioni} degli stessi dati senza duplicazione.
    \item Possono \textbf{semplificare query} complesse.
    \begin{itemize}
        \item Ad esempio, quando si devono comporre più operazioni \texttt{GROUP BY}, è possibile costruire una vista intermedia.
        \item Con SQL moderno è possibile usare subquery nella \texttt{FROM}, quindi l'uso delle viste per questo scopo è meno frequente ma resta utile per chiarezza.
    \end{itemize}
\end{itemize}

\subsubsection{Procedure e Funzioni}

Alcuni DBMS permettono di definire procedure e funzioni interne. Un esempio è il linguaggio \texttt{PL/SQL} di Oracle.

\vspace*{10px}

\begin{lstlisting}
    CREATE FUNCTION countStudents IS
    DECLARE
        total INTEGER;
    BEGIN
        SELECT COUNT(*) INTO total FROM STUDENTI;
        RETURN (total);
    END;
\end{lstlisting}

\newpage

\subsubsection{Trigger}

I \textbf{trigger} sono funzioni che vengono eseguite automaticamente al verificarsi di un determinato evento (ad esempio prima o dopo un \texttt{INSERT}, \texttt{UPDATE} o \texttt{DELETE}).

\vspace*{10px}

\begin{lstlisting}
    CREATE TRIGGER SalaryCheck
    BEFORE INSERT ON Employees
    DECLARE
        AvgSalary FLOAT;
    BEGIN
        SELECT AVG(Salary) INTO AvgSalary
        FROM Employees
        WHERE Department = :new.Department;

        IF :new.Salary > 2 * AvgSalary THEN
            RAISE_APPLICATION_ERROR(-2061, 'Salary too high');
        END IF;
    END;
\end{lstlisting}

\vspace*{-10px}

\begin{itemize}
    \item I trigger sono usati quando i vincoli coinvolgono \textbf{più tabelle}, poiché una semplice clausola \texttt{CHECK} opera solo sulla tupla corrente.
    \item Possono essere usati per mantenere valori derivati o contatori aggiornati automaticamente.
    \item I trigger possono vincolare anche operazioni di \texttt{DELETE}, mentre \texttt{CHECK} non può farlo.
\end{itemize}

\subsubsection{Access Control nel Database}

Il creatore di un database ha permessi completi: \texttt{CREATE}, \texttt{ALTER}, \texttt{DROP}.  
Può inoltre concedere permessi ad altri utenti, anche a livello di singola colonna.

\vspace*{10px}

\begin{lstlisting}
    GRANT Privileges ON Object
    TO Users [ WITH GRANT OPTION ];
\end{lstlisting}

\vspace*{-10px}

\paragraph{Indici}

Gli indici sono strutture dati utilizzate per velocizzare l'accesso ai dati nelle query.  
Tuttavia, un numero eccessivo di indici rallenta \textbf{inserimenti, modifiche e cancellazioni}, poiché anche gli indici devono essere aggiornati.

\paragraph{Catalogo - Metadata}

Il \textbf{catalogo} (o dizionario dati) contiene metadati sul database.  
Ad esempio:
\begin{itemize}
    \item Elenco delle tabelle del DB
    \item Tipi degli attributi
    \item Vincoli definiti
\end{itemize}

Ogni riga nella \emph{tabella delle tabelle} rappresenta una tabella del database.

\newpage

\section{Teoria della Normalizzazione}

La teoria della normalizzazione permette di definire equivalenze tra schemi relazionali ed anomalie in essi.

\paragraph{Buona Progettazione di Schemi Relazionali} Si basa sull'analisi di quattro proprietà:

\begin{itemize}
    \item \textbf{Semantica degli Attribuiti}: Progettazione mirata all'utilizzo di attributi che appartengano solo alla classe di quello schema.
    \item \textbf{Ridondanza}: Progettazione mirata a schemi in cui non siano presenti anomalie in caso di inserimento, cancellazione o modifica.
    \item \textbf{Valori Nulli}: Per quanto possibile, si progettano schemi in modo tale da evitare attributi che possono essere frequentemente nulli.
    \item \textbf{Tuple Spurie}: Le giunzioni tra schemi non dovrebbero mai generare tuple spurie.
\end{itemize}

\paragraph{Obiettivi della Teoria Normalizzazione} Fornire strumenti formali per la progettazione di basi di dati che non presentino anomalie, e grazie all'equivalenza,
permettere anche la ricerca di uno schema equivalente ad uno già esistente ma senza anomalie. I \textbf{problemi} quindi di cui si occupa la \textbf{teoria della normalizzazione} sono:

\begin{itemize}
    \item \textbf{Equivalenza tra Schemi}: Definire quando due schemi siano equivalenti.
    \item \textbf{Qualità degli Schemi}: Definire criteri di bontà di schemi.
    \item \textbf{Trasformazione di Schemi}: Definire metodi algoritmici per ottenere da uno schema un altro schema che sia migliore di quello di partenza.
\end{itemize}

\paragraph{Schema di Relazione Universale} Definiamo formalmente l'insieme universo degli attributi. Lo schema di relazione universale $U$ di una base di dati relazionale ha come attributi l'unione
degli attributi di tutte le relazioni della base di dati.

\paragraph{Notazione} Definiamo un po' di notazione utile:

\begin{itemize}
    \item $A,B,C,A_{1},A_{2}$ indicano singoli attributi.
    \item $T,X,Y,X_{1}$ indicano insiemi di attributi.
    \item Potenziali Abbreviazioni:
    \begin{itemize}
        \item $XY$ è abbreviazione per $X \cup Y$.
        \item $AB$ è abbreviazione per $\{ A,B \}$.
        \item $XA$ è abbreviazione per $X \cup \{A\}$.
    \end{itemize}
    \item $R(T)$ è un generico schema, $r$ è una sua istanza e $t$ è una n-upla di $r$.
    \item Se $X \subseteq T$ allora $t[X]$ indica l'n-upla ottenuta da $t$ considerando solo gli attributi in $X$.
\end{itemize}

\newpage

\subsection{Dipendenze Funzionali}

Vogliamo formalizzare la \textbf{nozione di schema senza anomalie}, occorre quindi \textbf{descrivere formalmente} la \textbf{semantica} dei dati in una istanza dello schema relazionale. Quindi definiamo come \textbf{aspetto estensionale} quello che si riferisce al \textbf{contenuto dei dati},
ed \textbf{aspetto intensionale} quello che si riferisce al \textbf{significato dei dati}.

\subsubsection{Definizione Formale di Dipendenza Funzionale e Significato}

Dato uno schema $R(T)$ e $X,Y \subseteq T$, una dipendenza funzionale \texttt{DF} è un \textbf{vincolo} su $R$ del tipo $X \rightarrow Y$, ossia
\vspace*{-2px}
\[ X \: \text{determina funzionalmente} \: Y \]
\[\text{o in maniera equivalente}\]
\[ Y \: \text{è determinata funzionalmente da} \: X \]

se vale che per ogni $r$ istanza valida di $R$ un valore di $X$ determina in modo univoco un valore di $Y$, formalmente definito come:

\begin{itemize}
    \item $\forall r$ istanza valida di $R$.
    \item $\forall t_{1}, t_{2} \in r \: \text{vale che} \: t_{1}[X] = t_{2}[X] \Rightarrow t_{1}[Y] = t_{2}[Y] $
\end{itemize}

\paragraph{Spiegazione Definizione} In un istanza $r$ di $R(T)$ è soddisfatta la dipendenza $X \rightarrow Y$ se per ogni coppia
di n-uple $t_1, t_2 \in r$  è vero che $t_{1}[X] = t_{2}[X] \Rightarrow t_{1}[Y] = t_{2}[Y]$.

\paragraph{Caratteristiche Dipendenze Funzionali} Queste dipendenze sono definite solo 

all'interno di uno schema di relazione e non possono esistere tra attributi di schemi diversi. Oltre a questo sono proprietà intensionali, sono legate alla semantica assegnata all'attributo e non possono quindi essere
inferite sulla base dell'osservazione di alcune istanze della relazione.

\subsubsection{Definizioni Formali di Chiave, Superchiave e Chiave Primaria}

Dato un insieme $K$ di attributi per uno schema di relazione $r$:

\begin{itemize}
    \item \textbf{Superchiave}: L'insieme $K$ è superchiave se \textbf{non contiene} due n-uple distinte $t_{1}, t_{2}$ con $t_{1}[K] = t_{2}[K]$. Quindi l'insieme di attributi $K$ identifica univocamente una n-upla.
    \item \textbf{Chiave}: L'insieme $K$ è \textbf{chiave se è superchiave minimale}, ossia non contiene un altra superchiave al suo interno. Quindi se eliminassimo degli attributi questa non sarebbe più una superchiave.
    \item \textbf{Chiave Primaria}: Una delle chiavi dello schema di relazione, solitamente si preferisce quella con meno attributi.
\end{itemize}

\newpage

\subsubsection{Dipendenza Funzionale e Soddisfacibilità su Istanze}

Introduciamo un nuovo operatore $\models$ (soddisfa):

\begin{itemize}
  \item un'istanza $r_0$ di $R$ \textbf{soddisfa} la DF $X \to Y$
  se:
  \[
  r_0 \models X \to Y
  \]
  cioè se:
  \[
  \forall t_1, t_2 \in r_0,\ t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y]
  \]
  \item un istanza $r_0$ \textbf{soddisfa} un insieme $F$ di $DF$ se:
  \[ \forall X \to Y \in F vale r_0 \models X \to Y \]
  cioè se
  \[ r_0 \models X \to Y \: \text{se} \: \forall t_1,t_2 \in r_0 \: \text{vale che} \: t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y] \]
\end{itemize}

\subsubsection{Dipendenze Funzionali Atomiche e Banali}

\begin{itemize}
    \item \textbf{Atomica}: Ogni dipendenza del tipo $X \to A_1 A_2 \cdots A_n$ è scomponibile in $X \to A_1, X \to A_2 \cdots, X \to A_n$. La seconda tipologia è detta \textbf{atomica}.
    \item \textbf{Banale}: Una dipendenza del tipo $Progetto \to Progetto$ è detta \textbf{banale}.
\end{itemize}

\subsection{Utilizzo di Dipendenze Funzionali}

Vogliamo utilizzare uno schema di relazione e le sue dipendenze per ricavarne altre, quindi definiamo da adesso in poi lo schema come $R(T,F)$ con $F$ insieme di
dipendenze funzionali su $T$.

\subsubsection{Derivazione di Dipendenze Funzionali}

Basandoci sulla definizione data prima di soddisfacibilità di istanze, dato $R(T,F)$ diciamo che $F \models X \to Y$ se ogni istanza $r \in R(T)$ che soddisfa $F$ soddisfa anche $X \to Y$.

\subsubsection{Assiomatizzazione delle Dipendenze Funzionali} Sia $RI$ un insieme di regole di inferenza per $F$, utilizzeremo $RI$ per derivare altre dipendenze funzionali a partire da $F$.

Indichiamo con $F \vdash X \to Y$ il fatto che $X \to Y$ sia derivabile da $F$ usando $RI$.

\paragraph{Correttezza e Completezza di un Insieme di Regole di Inferenza} Esistono due proprietà principali di un sistema d'inferenza:

\begin{itemize}
    \item \textbf{Correttezza}: L'insieme $RI$ se $F \vdash X \to Y$ implica $F \models X \to Y$.
    \item \textbf{Completezza}: L'insieme $RI$ se $F \models X \to Y$ implica $F \vdash X \to Y$.
\end{itemize}

\newpage

\subsubsection{Assiomi di Armstrong e Derivazioni}

Gli assiomi di Armstrong sono l'insieme noto corretto e completo di regole di inferenza. Elenchiamo queste regole:

\begin{itemize}
    \item \textbf{Riflessività}: se $Y \subseteq X$ allora $X \to Y$.
    \item \textbf{Arricchimento}: se $X \to Y$, $Z \subseteq T$ allora $XZ \to YZ$.
    \item \textbf{Transitività}: se $X \to Y$, $Y \to Z$ allora $X \to Z$
\end{itemize}

Da queste possiamo derivarne altre:

\begin{itemize}
    \item \textbf{Unione}: $\{ X \to Y, X \to Z \} \vdash X \to YZ$
    \item \textbf{Decomposizione}: $\{ X \to YZ \} \vdash X \to Y$
    \item \textbf{Indebolimento}: $\{ X \to Y \} \vdash XZ \to Y$
    \item \textbf{Identità}: $\{ \} \vdash X \to Y $
\end{itemize}

\paragraph{Teorema di Correttezza e Completezza Assiomi di Armstrong} Gli assiomi di Armstrong sono corretti e completi. Attraverso gli assiomi stessi si può mostrare l'equivalenza tra
implicazione logica $\models$ e derivazione $\vdash$. Questo perchè se una dipendenza è derivabile con gli assiomi di Armstrong allora è anche implicata logicamente (per la correttezza degli assiomi), e viceversa se una dipendenza
è implicata logicamente allora è anche derivabile dagli assiomi (per completezza degli assiomi).

\begin{itemize}
    \item \textbf{Correttezza}: $\forall f \:\: F \vdash f \Rightarrow F \models f$
    \item \textbf{Completezza}: $\forall f \:\: F \models f \Rightarrow F \vdash f$
\end{itemize}

\subsubsection{Chiusura di un Insieme}

Dato un insieme $F$ di $DF$ la chiusura di $F$ è $F^{+} = \{ X \to Y \: | \: F \vdash X \to Y \}$. 

\vspace*{10px}

Contestualizzando ad una $R(T,F)$ data con $X \subseteq T$ la chiusura di $X$ rispetto ad $F$ denotata con $X_{F}^{+}$ è \[ X_{F}^{+} = \{ A_{i} \in T \: | \: F \vdash X \to A_{i} \} \]

\subsubsection{Algoritmo della Chiusura Lenta}

Vogliamo decidere, data una $DF$, se questa appartiene a $F^+$. Applicare ripetutamente gli assiomi di Armstrong ha una complessità esponenziale rispetto al numero di attributi dello schema. Si preferisce quindi utilizzare un algoritmo basato su uno specifico teorema.

\paragraph{Teorema} La $DF: X \to Y$ è derivabile da $F$ se e solo se $Y$ è sottoinsieme della chiusura di $X$ rispetto ad $F$ formalmente definito come:

\[ F \vdash X \to Y \Leftrightarrow Y \subseteq X_{F}^{+} \]

\newpage

\paragraph{Definizione di Chiavi tramite Dipendenze e Chiusura}

\begin{itemize}
    \item \textbf{Superchiave}: Dato lo schema $R(T,F)$, un insieme di attributi $W \subseteq T$ è una \textbf{superchiave} di $R$ se $W \to T \in F^{+}$.
    \item \textbf{Chiave}: Dato lo schema $R(T,F)$, un insieme di attributi $W \subseteq T$ è una \textbf{chiave} di $R$ se $W$ è una superchiave e non esiste un sottoinsieme stretto di $W$ che sia superchiave di $R$.
    \item \textbf{Attributo Primo}: Dato lo schema $R(T,F)$, un attributo $A \in T$ si dice \textbf{attributo primo} se e solo se appartiene ad almeno una chiave, altrimenti si dice non primo.
\end{itemize}

\paragraph{Proprietà Interessanti per Ricerca di Chiavi} L'algoritmo per trovare tutte le chiavi si basa su due proprietà:

\begin{itemize}
    \item Se un attributo $A$ di $T$ \textbf{non appare a destra} di alcuna dipendenza in $F$, allora $A$ \textbf{appartiene} ad ogni chiave di $R$, altrimenti non può essere determinato.
    \item Se un attributo $A$ di $T$ \textbf{appare a destra} di qualche dipendenza in $F$, \textbf{ma non appare a sinistra} di alcuna dipendenza non banale, allora A \textbf{non appartiene ad alcuna chiave}.
\end{itemize}

\paragraph{Esempio di Derivazione} Dato $F = \{ DB \to E, B \to C, A \to B \}$ trovare $(AD)^+$:

\[ X^+ = AD = ADB = ADBE = ADBEC \]

Quindi data questa produzione, possiamo ad esempio notare che $AD$ è superchiave perchè contiene tutti gli attributi ed $A$ \textbf{non è superchiave} perchè la produzione $A \to B, A \to BC$ si ferma.

\newpage

%\begin{figure}[htbp]
    %\center
    %\includegraphics[scale=0.4]{img/classiComplessita2.png}
%\end{figure}


\end{document}