# Lezione BD 22/10/2025

- L'SQL da solo non è un linguaggio di programmazione completo
- Il codice del processo main ed il processo del DBMS sono differenti, quindi questi comunicano tra loro con IPC.

## Tipi di linguaggi

1. **Linguaggio Integrato**: PL/SQL definito ad esempio da Oracle è SQL esteso fino a quando non diventa un linguaggio completo, quindi viene compilato contemporanemanente sia l'SQL sia la parte di programmazione standard.
    - Vantaggio: Viene compilato ed eseguito direttamente dal DBMS, quindi operazioni come controlli per ruoli d'accesso in compilazione.
    - Oracle PL/SQL, permette la lettura di tipi del BD e utilizzarli per la dichiarazione di variabili. Anche in questo caso il codice SQL viene utilizzato come **template** che verrà interpretato secondo l'SQL e sostituito sintatticamente per poi eseguire il linguaggio esterno.
2. **Linguaggio Convenzionale + API**: Si utilizza una libreria più interfaccia per l'interazione tra il processo del linguaggio convenzionale e l'interazione con il DBMS.
    - In questo contesto, il linguaggio convenzionale non effettua controlli statici sull'SQL, perchè viene considerata come una **normale stringa**.
    - Vantaggio: Si inviano quindi in stringhe al DBMS.
    - In ogni caso quindi non si risolve il dismatch causato dagli elementi come `NULL` o `MAX_INT`.
3. **SQL Ospitato**: Approccio che utilizza costrutti di `begin SQL` ed `end SQL`, quindi le variabili tra le due parti sono condivise tra ad esempio Python ed SQL. 
    - Il precompilatore si occupa di compilare e chiamare l'API, quindi vengono fatti dei controlli a tempo di compilazione anche per l'SQL, forte differenza con la tipologia mostrata prima.
    - Genera problemi a causa della traduzione dell'SQL, magari problemi piccoli di cui potremmo non accorgerci.
    - Altri problemi anche di forza di espressività magari sugli insiemi o record tra il linguaggio host e l'SQL.

# Lezione BD 28/10/2025

## Esercizio a1

Per tutti i pazienti che sono associati almeno a patologie con categoria autoimmune, restituire idpz, nome, cognome (3 righe, oppure 1)

```SQL
SELECT DISTINCT p.IdPz, p.Nome, p.Cognome
FROM Pazienti p JOIN PazientiPatologie pp ON 
    JOIN Patologie pt ON pp.IdPt=pt.ItPt
WHERE pt.Categoria = 'autoimmune'
```

## Esercizio a2

Per tutti i pazienti che sono associati solo a patologie con categoria autoimmune, restituire idpz, nome, cognome (3 righe, oppure 1)

### Tipologia 3 righe

```SQL
SELECT p.IdPz, p.Nome, p.Cognome
FROM Pazienti p
WHERE NOT EXISTS (
    SELECT *
    FROM PazientiPatologie pp
    JOIN Patologie pt ON pp.IdPt=pt.ItPt
    WHERE p.IdPz = pp.IdPz AND NOT (pt.Categoria = 'autoimmune')
)
```

### Tipologia 1 riga

```SQL
SELECT p.IdPz, p.Nome, p.Cognome
FROM Pazienti p
WHERE NOT EXISTS (
    SELECT *
    FROM PazientiPatologie pp1
    JOIN Patologie pt ON pp1.IdPt=pt.ItPt
    WHERE p.IdPz = pp1.IdPz AND NOT (pt.Categoria = 'autoimmune') //QUERY UNIVERSALE
    AND EXISTS ( //QUERY ESISTENZIALE
        SELECT *
        FROM PazientiPatologie pp2
        WHERE p.IdPz = pp2.IdPz
    )
)
```

## Esercizio b

Per ogni categoria di farmaci restituire il numero di tutte le patologie associate a un farmaco di quella categoria

```SQL
SELECT f.Categoria, COUNT(*) as NumPatologie
FROM Farmaci f JOIN PatologieFarmaci pf ON f.Id = pf.IdF
GROUP BY f.Categoria
```

## Esercizio c

Per ogni coppia di patologie diverse che hanno un farmaco in comune, restituisci il nome della prima e il nome della seconda

### Versione con JOIN

```SQL
SELECT DISTINCT p1.Nome, p2.Nome
FROM Patologie p1, Patologie p2
JOIN PatologieFarmaci pf1 ON p1.IdPt = pf1.IdPt
JOIN PatologieFarmaci pf2 ON pf1.IdPt = pf2.IdPt 
JOIN Patologie p2 ON pf2.IdPt = p2.IdPt
WHERE p1.IdPt != p2.IdPt
```

- Se facciamo delle `JOIN` allora risulta necessario aggiungere `DISTINCT`

### Versione con EXISTS (Prodotto Cartesiano e successiva Condizione)

```SQL
SELECT p1.Nome, p2.Nome
FROM Patologie p1, Patologie p2
WHERE p1.IdPt != p2.IdPt
    AND EXISTS (
        SELECT *
            FROM PatologieFarmaci pf1
            FROM PatologieFarmaci pf2 ON pf1.IdF = pf2.IdF
            WHERE p1.IdPt = pf2.IdF

    )
```

- In questo caso non serve utilizzare in DISTINCT dato che stiamo utilizzando l'approccio prodotto cartesiano + condizione successiva

- Se vediamo due patologieFarmaci con un farmaco in comune abbiamo allora necessità di tornare due volte nella tabella patologieFarmaci per recuperare l'informazione

## Esercizio d

Per ogni coppia di patologie diverse 

```SQL
SELECT DISTINCT p1.Nome, p2.Nome, COUNT(*) as NumFarmaci
FROM Patologie p1
JOIN PatologieFarmaci pf1 ON p1.IdPt = pf1.IdPt
JOIN PatologieFarmaci pf2 ON pf1.IdPt = pf2.IdPt 
JOIN Patologie p2 ON pf2.IdPt = p2.IdPt
WHERE p1.IdPt < p2.IdPt
GROUP BY p1.Nome, p2.Nome

```

- Se uso la condizione `!=` o `<` allora non utilizzo, in caso di molteplici join, nessuna delle righe della tabella della relazione n-m verrà utilizzata sia per la tabella1 che per la tabella2, ma solo per tabelle distinte

## Esercizio e1

Restituire il nome dei pazienti affetti da qualche patologia per la quale esiste un farmaco il cui costo è strettamente inferiore a 50

```SQL
SELECT pz.Nome
FROM Pazienti pz
FROM PatologiePazienti pp ON pz.IdPz=pp.IdPz
JOIN Patologie p ON pp.IdPt=p.IdPt
FROM PatologieFarmaci pf ON p.IdPt=pf.IdPt
JOIN Farmaci f ON pf.IdF=f.IdF
WHERE f.Prezzo < 50
```

## Esercizio e2 --- NON COMPLETO VEDI SOLUZIONI

```SQL
SELECT pz.Nome
FROM Pazienti pz
    (SELECT *
        FROM PatologiePazienti pp ON pz.IdPz=pp.IdPz
        JOIN Patologie p ON pp.IdPt=p.IdPt
        WHERE pz.IdPz=pp.IdPz
    )
    AND EXISTS (


    )
FROM PatologieFarmaci pf ON p.IdPt=pf.IdPt
JOIN Farmaci f ON pf.IdF=f.IdF
WHERE f.Prezzo < 50
```

## Esercizio e3 --- NON COMPLETO VEDI SOLUZIONI

# Lezione BD 29/10/2025 - SQL for Data Definition

## CREATE TABLE

Come si definisce una tabella in SQL, bisogna saperla leggere, non verrà mai esplicitamente richiesto di creare tabelle esplicitamente

```SQL
CREATE TABLE Employees( 
    Code CHAR(8) NOT NULL,
    Name CHAR(20),
    Birthyear INTEGER CHECK (Birthyear < 2005),
    Qualification CHAR(20) DEFAULT ‘Employee’,
    Supervisor CHAR(8),
    PRIMARY KEY pk_ Employees (Code),
    FOREIGN KEY fk_ Employees (Supervisor)
    REFERENCES Employees )

CREATE TABLE Dependents(
    Name CHAR(20),
    Birthyear INTEGER,
    EmployeeCode CHAR(8),
    FOREIGN KEY fk_ Dependents (EmployeeCode)
    REFERENCES Employees )
```
- Nella foreign key va specificato quale sia il campo e a cosa punta.
- Esistono anche i comandi `DROP` e `ALTER` che rispettivamente permettono di cancellare la tabella e modificarla.
- **Vincolo di Foreign Key**: Se cancellassi qualcosa di puntato, allora la foreign key che lo puntava deve diventare nulla. O la possibilità di settare comportamenti diversi sulla delete come `CASCADE`

## Viste e Viste Materializzate - CREATE VIEW

### Viste Materializzate

Si crea una nuova tabella su una tabella preesistente, calcolando una query, materializzando una vista in una **tabella effettiva** (in copia).

```SQL
CREATE TABLE Name SelectExpression

CREATE TABLE Supervisors
SELECT Code, Name, Qualification, Salary
FROM Employees
WHERE Supervisor IS NULL
```

Questo va bene in contesti in cui i cambi dei dati non sono variabili frequentemente, perchè se utilizzassimo questo approccio allora nelle viste non vedremmo le modifiche riportate nella tabella originale.

### Viste

Viste virtuali, basate su query memorizzate ma in lazy, come delle vere e proprie funzioni che possono essere valutate, ma ancora non lo sono.

```SQL
CREATE VIEW Name [(Attribute {, Attribute})]
AS SelectExpression [WITH CHECK OPTION];

CREATE VIEW Supervisors
AS SELECT Code, Name, Qualification, Salary
FROM Employees
WHERE Supervisor IS NULL
```

Solitamente non vengono aggiornate le viste, dato che sono query memorizzate e virtuali

### Motivazioni dell'utilizzo delle viste

- Permette di nascondere dati ad alcune interfacce, mantenendo l'**indipendenza logica**.
- Permette di vedere gli **stessi dati** da più lati **senza duplicazione**, magari variando l'**interpretazione in base al punto di vista**.
- Permette la semplificazione di query da alcuni punti di vista.
    - Questo accade se volessi comporre più funzioni della GROUP BY, dato che in SQL non posso comporre queste funzioni. Quindi creo una vista che si occupa della prima operazione, e successivamente riapplico una GROUP BY alla vista.
    - Oggigiorno è possibile utilizzare il risultato di una query nella FROM, di conseguenza è meno utilizzato questo approccio, ma definire la view in ogni caso aiuterebbe la semplificazione di questo processo.

## Procedure e Funzioni - CREATE PROCEDURE/FUNCTION

Alcuni DBMS ci permettono di definire vere e proprie funzioni, come in questo caso in PLSQL

```SQL
CREATE FUNCTION countStudents IS
DECLARE
total INTEGER;
BEGIN
SELECT COUNT(*) INTO tot FROM STUDENTI;
RETURN (total);
END
```

### Trigger

Funzioni che vengono eseguite in specifiche condizioni, ad esempio alla creazione di una entry in una tabella:

```SQL
CREATE TRIGGER SalaryCheck
BEFORE INSERT ON Employees
DECLARE
AvgSalary FLOAT
BEGIN
SELECT avg(Salary) INTO AvgSalary
FROM Employees
WHERE Department = :new.Department;
IF :new.Salary > 2 * AvgSalary
THEN RAISE_APPL._ERR.(-2061, ‘Salary too high’)
END IF;
END;
```

- I trigger vengono usati quando ci sono vincoli che trattano tabelle diverse, perchè fosse stato solo per una tabella allora sarebbe bastata una clausola `CHECK`.
- I trigger vengono utilizzati anche per aggiornare dati quando occorrono specifiche condizioni. Magari incrementare/decrementare contatori ad ogni specifica QUERY.
- I trigger possono vincolare anche delle `DELETE`, mentre la clausola `CHECK` non può farlo.

## Access Control di un Database

Chi crea un DB è l'unico a poter effettuare su di esso degli `ALTER`, `CREATE` e `DROP`. Il creatore di DB può anche fornire permessi, anche a livelli di colonne.

```SQL
GRANT Privileges ON Object
TO Users [ WITH GRANT OPTION ]
```

## Indici

Strutture dati per la velocizzazione di query. Permette la velocizzazione, ma utilizzarne troppi causerebbe problemi durante la modifica dei dati, essendo che vanno aggiornati anche tutti gli indici.

## Catalog - Metadata

Tabella delle tabelle, possiamo accedervi per ottenere metadati riguardanti il DB, ad esempio il numero di tabelle. Quindi ogni riga della tabella delle tabelle fa riferimento ad una tabella del DB.

## Parte SQL 

### Esercizio G

```SQL
SELECT f.Categoria, f.IdF, f.Nome
FROM Farmaci f
WHERE f.Prezzo "è il meno costoso della categoria"
```

come trasformiamo quella frase ad alto livello? 

#### Prima Query

```SQL
SELECT f.Categoria, f.IdF, f.Nome
FROM Farmaci f
WHERE f.Prezzo <= ALL (
    SELECT f1.Prezzo
    FROM Farmaci f1
    WHERE f1.Categoria = f.Categoria
)
```

#### Seconda Query - Tramite GROUP BY (IMPLICITA)

```SQL
SELECT f.Categoria, f.IdF, f.Nome
FROM Farmaci f
WHERE f.Prezzo = (
    SELECT MIN(f1.Prezzo)
    FROM Farmaci f1
    WHERE f1.Categoria = f.Categoria
)
```

#### Terza Query - Tramite Negazione della condizione sulla prima query

```SQL
SELECT f.Categoria, f.IdF, f.Nome
FROM Farmaci f
WHERE NOT EXISTS (
    SELECT *
    FROM Farmaci f1
    WHERE f1.Categoria = f.Categoria
    AND f1.Prezzo < f.Prezzo
)
```

#### Quarta Query - Tramite JOIN, GROUP BY, HAVING

```SQL
SELECT f.Categoria, f.IdF, f.Nome
FROM Farmaci f, Farmaci f1
WHERE f.Categoria = f1.Categoria
GROUP BY f.Categoria, f.IdF, f.Nome, f.Prezzo
HAVING f.Prezzo = MIN(f1.Prezzo)
```

### Esercizio H

Per ogni paziente, nome idPz e numero di patologie //vedi traccia

```SQL
SELECT pz.IdPz, pz.Nome, COUNT(*) as NumPatologie
FROM Pazienti pz JOIN PatologiePazienti pp USING (IdPz)
GROUP BY pz.IdPz, pz.Nome
ORDER BY COUNT(*) ASC
```

In questo modo non catturiamo chi ha 0, possiamo farlo tramite una `LEFT JOIN`, e passando un campo al count, così chi ha null viene quantificato e contato.

```SQL
SELECT pz.IdPz, pz.Nome, COUNT(pp.IdPt) as NumPatologie
FROM Pazienti pz LEFT JOIN PatologiePazienti pp USING (IdPz)
GROUP BY pz.IdPz, pz.Nome
ORDER BY COUNT(*) ASC
```

### Esercizio I

Trovare chi non ha malattie

#### Tramite LEFT JOIN
```SQL
SELECT pz.IdPz, pz.Nome
FROM Pazienti pz LEFT JOIN PatologiePazienti pp USING (IdPz)
WHERE pp.IdPt IS NULL
```

Nota che non si usa `=NULL`

#### Tramite NOT EXISTS

```SQL
SELECT pz.IdPz, pz.Nome
FROM Pazienti pz
WHERE NOT EXISTS (
    SELECT *
    FROM PatologiePazienti pp
    WHERE pz.IdPz = pp.IdPz
)
```

#### Tramite NOT IN --- vedi soluzioni

```SQL
SELECT pz.IdPz, pz.Nome
FROM Pazienti
WHERE pzNOT IN
```

# Lezione BD 04/11/2025 - Esercitazione

BD2025B

## Esercizio 1 - Progettazione Agenzia Immobiliare

### Identificazione Classi

- Immobili
    - Codice
    - Tipo
    - Superficie
    - NumeroVani
    - PrezzoAlMetroQuadro
    - *EventualiAnnessi
    - TipoContratto
        - *Locazioni
            - Affitto
        - *Vendite
            - PrezzoRichiesto
    - Proprietario
- Contratti
- Vendite $\rightarrow$ Contratti
    - PrezzoRichiesto
- Locazioni $\rightarrow$ Contratti
    - Affitto
- Appuntamenti
    - Codice
    - Immobile
    - InsiemeClientiInteressati
    - Data
    - Orario
    - PresenzaProprietario
- Persone
    - CodiceFiscale
    - Cognome
    - Nome
    - NumTelefonico
    - Email
- Proprietari $\rightarrow$ Persone
    - *ImmobiliInVenditaDiSuaProprieta
- AgentiImmobiliari $\rightarrow$ Persone
    - ImmobiliCheFaVisitare
- Clienti $\rightarrow$ Persone
    - TipologiaImmobile_e_AcquistiCercati

## Esercizio 2 - Query SQL

- Query C

    Per ogni città il numero di sale con più di 60 posti

    ```SQL
    SELECT S.Citta, count(*)
    FROM Sale s
    WHERE s.Posti > 60
    GROUP BY S.Citta
    ```

- Query D

    Per ogni regista il numero di film diretti dopo il 1990

    ```SQL
    SELECT COUNT(*), f.Regista
    FROM Film f
    WHERE f.Anno > 1990
    GROUP BY f.Regista
    ```

    Il filtro delle HAVING è applicabile solo sulle funzioni di aggregazione, non su i campi base

- Query E

    Per ogni regista, l’incasso totale di tutte le proiezioni dei suoi film

    ```SQL
    SELECT f.Regista, SUM(p.Incasso)
    FROM Film f JOIN Proiezioni p USING CodFilm
    GROUP BY f.Regista
    ```

- Query F

    Per ogni film di S.Spielberg, il titolo del film, il numero totale di proiezioni a Pisa e l’incasso totale (a Pisa)

    ```SQL
    SELECT f.Titolo, COUNT(*), SUM(p.Incasso)
    FROM Film f JOIN Proiezioni p USING CodFilm
                JOIN Sale s USING CodSale
    WHERE s.Citta = "Pisa" AND f.Regista = "Spielberg"
    GROUP BY f.Titolo
    ```

- Query G

    Per ogni regista e per ogni attore, il numero di film del regista con l’attore

    ```SQL
    SELECT a.Nome, a.Cognome, f.Regista, COUNT(*)
    FROM Film f JOIN Recita USING CodFilm
                JOIN Attori a USING CodAttore
    GROUP BY a.Nome, f.Regista
    ```

- Query H

    Il regista ed il titolo dei film in cui recitano meno di 6 attori (N.B. questa interrogazione non restituisce i film in cui non recita alcun attore)

    ```SQL
    SELECT f.Regista, f.Titolo
    FROM Film f JOIN Recita USING CodFilm
                JOIN Attori a USING CodAttore
    GROUP BY f.Regista, f.Titolo
    HAVING COUNT(*) < 6
    ```

- Query I

    Per ogni film prodotto dopo il 2005, il codice, il titolo e l’incasso totale di tutte le sue proiezioni

    ```SQL
    SELECT f.Titolo, f.Codice, SUM(p.Incasso)
    FROM Film f JOIN Proiezioni p USING CodFilm
    WHERE f.AnnoProduzione > 2005
    GROUP BY f.Titolo
    ```

- Query L

    Il numero di attori dei film in cui appaiono solo attori nati prima del 1930

    ```SQL
    SELECT COUNT(*), a.Nome
    FROM Film f JOIN Recita USING CodFilm
            JOIN Attori a USING CodAttore
    WHERE NOT EXISTS (
        SELECT *
        FROM Attori a1
        WHERE 
        WHERE a1.AnnoNascita < 1930
    )
    GROUP BY a.Nome
    ```

    RIVEDI BENE QUESTA QUERY
